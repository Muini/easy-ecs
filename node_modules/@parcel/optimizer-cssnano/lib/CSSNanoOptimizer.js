"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sourceMap = _interopRequireDefault(require("@parcel/source-map"));

var _plugin = require("@parcel/plugin");

var _postcss = _interopRequireDefault(require("postcss"));

var _cssnano = _interopRequireDefault(require("cssnano"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// flowlint-next-line untyped-import:off
var _default = new _plugin.Optimizer({
  async optimize({
    bundle,
    contents: prevContents,
    getSourceMapReference,
    map: prevMap,
    options
  }) {
    if (!bundle.env.minify) {
      return {
        contents: prevContents,
        map: prevMap
      };
    }

    if (typeof prevContents !== 'string') {
      throw new Error('CSSNanoOptimizer: Only string contents are currently supported');
    }

    const result = await (0, _postcss.default)([_cssnano.default]).process(prevContents, {
      // Suppress postcss's warning about a missing `from` property. In this
      // case, the input map contains all of the sources.
      from: undefined,
      map: {
        annotation: false,
        inline: false,
        prev: prevMap ? await prevMap.stringify({}) : null
      }
    });
    let map;

    if (result.map != null) {
      map = new _sourceMap.default();
      map.addRawMappings(result.map.toJSON());
    }

    let contents = result.css;

    if (options.sourceMaps) {
      let reference = await getSourceMapReference(map);

      if (reference != null) {
        contents += '\n' + '/*# sourceMappingURL=' + reference + ' */\n';
      }
    }

    return {
      contents,
      map
    };
  }

});

exports.default = _default;