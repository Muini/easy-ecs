"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("@parcel/utils");

var _plugin = require("@parcel/plugin");

var _fileSystemLoader = _interopRequireDefault(require("css-modules-loader-core/lib/file-system-loader"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _path = _interopRequireDefault(require("path"));

var _postcss = _interopRequireDefault(require("postcss"));

var _semver = _interopRequireDefault(require("semver"));

var _postcssValueParser = _interopRequireDefault(require("postcss-value-parser"));

var _loadConfig = require("./loadConfig");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const COMPOSES_RE = /composes:.+from\s*("|').*("|')\s*;?/;
const FROM_IMPORT_RE = /.+from\s*(?:"|')(.*)(?:"|')\s*;?/;

var _default = new _plugin.Transformer({
  loadConfig({
    config,
    options,
    logger
  }) {
    return (0, _loadConfig.load)({
      config,
      options,
      logger
    });
  },

  preSerializeConfig({
    config
  }) {
    return (0, _loadConfig.preSerialize)(config);
  },

  postDeserializeConfig({
    config,
    options
  }) {
    return (0, _loadConfig.postDeserialize)(config, options);
  },

  canReuseAST({
    ast
  }) {
    return ast.type === 'postcss' && _semver.default.satisfies(ast.version, '^7.0.0');
  },

  async parse({
    asset,
    config
  }) {
    if (!config) {
      return;
    }

    return {
      type: 'postcss',
      version: '7.0.0',
      program: _postcss.default.parse((await asset.getCode()), {
        from: asset.filePath
      })
    };
  },

  async transform({
    asset,
    config,
    options,
    resolve
  }) {
    asset.type = 'css';

    if (!config) {
      return [asset];
    }

    let plugins = [...config.hydrated.plugins];

    if (config.hydrated.modules) {
      let postcssModules = await options.packageManager.require('postcss-modules', asset.filePath, {
        autoinstall: options.autoinstall
      });
      plugins.push(postcssModules({
        getJSON: (filename, json) => asset.meta.cssModules = json,
        Loader: createLoader(asset, resolve),
        generateScopedName: (name, filename, css) => `_${name}_${(0, _utils.md5FromString)(filename + css).substr(0, 5)}`,
        ...config.hydrated.modules
      }));
    }

    let ast = (0, _nullthrows.default)((await asset.getAST()));
    let code = asset.isASTDirty() ? null : await asset.getCode();

    if (code == null || COMPOSES_RE.test(code)) {
      ast.program.walkDecls(decl => {
        let [, importPath] = FROM_IMPORT_RE.exec(decl.value) || [];

        if (decl.prop === 'composes' && importPath != null) {
          let parsed = (0, _postcssValueParser.default)(decl.value);
          parsed.walk(node => {
            if (node.type === 'string') {
              asset.addDependency({
                moduleSpecifier: importPath,
                loc: {
                  filePath: asset.filePath,
                  start: decl.source.start,
                  end: {
                    line: decl.source.start.line,
                    column: decl.source.start.column + importPath.length
                  }
                }
              });
            }
          });
        }
      });
    } // $FlowFixMe Added in Flow 0.121.0 upgrade in #4381


    let {
      messages,
      root
    } = await (0, _postcss.default)(plugins).process(ast.program, config.hydrated);
    ast.program = root;
    asset.setAST({
      type: 'postcss',
      version: '7.0.0',
      program: root
    });

    for (let msg of messages) {
      if (msg.type === 'dependency') {
        msg = msg;
        asset.addIncludedFile({
          filePath: msg.file
        });
      }
    }

    let assets = [asset];

    if (asset.meta.cssModules) {
      let code = JSON.stringify(asset.meta.cssModules, null, 2);
      let deps = asset.getDependencies().filter(dep => !dep.isURL);

      if (deps.length > 0) {
        code = `
          module.exports = Object.assign({}, ${deps.map(dep => `require(${JSON.stringify(dep.moduleSpecifier)})`).join(', ')}, ${code});
        `;
      } else {
        code = `module.exports = ${code};`;
      }

      assets.push({
        type: 'js',
        filePath: asset.filePath + '.js',
        content: code
      });
    }

    return assets;
  },

  generate({
    ast
  }) {
    let code = '';

    _postcss.default.stringify(ast.program, c => {
      code += c;
    });

    return {
      content: code
    };
  }

});

exports.default = _default;

function createLoader(asset, resolve) {
  return class extends _fileSystemLoader.default {
    async fetch(composesPath, relativeTo) {
      let importPath = composesPath.replace(/^["']|["']$/g, '');
      let resolved = await resolve(relativeTo, importPath);

      let rootRelativePath = _path.default.resolve(_path.default.dirname(relativeTo), resolved);

      let root = _path.default.resolve('/'); // fixes an issue on windows which is part of the css-modules-loader-core
      // see https://github.com/css-modules/css-modules-loader-core/issues/230


      if (rootRelativePath.startsWith(root)) {
        rootRelativePath = rootRelativePath.substr(root.length);
      }

      let source = await asset.fs.readFile(resolved, 'utf-8');
      let {
        exportTokens
      } = await this.core.load(source, rootRelativePath, undefined, this.fetch.bind(this));
      return exportTokens;
    }

    get finalSource() {
      return '';
    }

  };
}