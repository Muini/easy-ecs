"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var types = _interopRequireWildcard(require("@babel/types"));

var _utils = require("@parcel/utils");

var _utils2 = require("./utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const serviceWorkerPattern = ['navigator', 'serviceWorker', 'register'];
var _default = {
  ImportDeclaration(node, {
    asset
  }) {
    asset.meta.isES6Module = true;
    addDependency(asset, node.source);
  },

  ExportNamedDeclaration(node, {
    asset
  }) {
    asset.meta.isES6Module = true;

    if (node.source) {
      addDependency(asset, node.source);
    }
  },

  ExportAllDeclaration(node, {
    asset
  }) {
    asset.meta.isES6Module = true;
    addDependency(asset, node.source);
  },

  ExportDefaultDeclaration(node, {
    asset
  }) {
    asset.meta.isES6Module = true;
  },

  CallExpression: {
    enter(node, {
      asset,
      ast
    }, ancestors) {
      let {
        callee,
        arguments: args
      } = node;
      let isRequire = types.isIdentifier(callee) && callee.name === 'require' && args.length === 1 && types.isStringLiteral(args[0]) && !(0, _utils2.hasBinding)(ancestors, 'require') && !(0, _utils2.isInFalsyBranch)(ancestors);

      if (isRequire) {
        let isOptional = ancestors.some(a => types.isTryStatement(a)) || undefined;
        let isAsync = isRequireAsync(ancestors, node, asset, ast);
        addDependency(asset, args[0], {
          isOptional,
          isAsync
        });
        return;
      }

      let isRequireResolve = types.isMemberExpression(callee) && types.matchesPattern(callee, 'require.resolve') && args.length === 1 && types.isStringLiteral(args[0]) && !(0, _utils2.hasBinding)(ancestors, 'require') && !(0, _utils2.isInFalsyBranch)(ancestors);

      if (isRequireResolve) {
        let isOptional = ancestors.some(a => types.isTryStatement(a)) || undefined;
        addDependency(asset, args[0], {
          isOptional
        });
        return;
      }

      let isDynamicImport = callee.type === 'Import' && args.length === 1 && types.isStringLiteral(args[0]);

      if (isDynamicImport) {
        // Ignore dynamic imports of fully specified urls
        if ((0, _utils.isURL)(args[0].value)) {
          return;
        }

        addDependency(asset, args[0], {
          isAsync: true
        });
        node.callee = types.identifier('require');
        asset.setAST(ast);
      }
    },

    exit(node, {
      asset,
      ast
    }, ancestors) {
      if (node.type !== 'CallExpression') {
        // It's possible this node has been morphed into another type
        return;
      }

      let {
        callee,
        arguments: args
      } = node;
      let isRegisterServiceWorker = types.isStringLiteral(args[0]) && types.matchesPattern(callee, serviceWorkerPattern) && !(0, _utils2.hasBinding)(ancestors, 'navigator') && !(0, _utils2.isInFalsyBranch)(ancestors);

      if (isRegisterServiceWorker) {
        // Treat service workers as an entry point so filenames remain consistent across builds.
        // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#avoid_changing_the_url_of_your_service_worker_script
        addURLDependency(asset, ast, args[0], {
          isEntry: true,
          env: {
            context: 'service-worker'
          }
        });
        return;
      }

      let isImportScripts = asset.env.isWorker() && callee.name === 'importScripts';

      if (isImportScripts) {
        for (let arg of args) {
          if (types.isStringLiteral(arg)) {
            addURLDependency(asset, ast, arg);
          }
        }
      }
    }

  },
  NewExpression: {
    exit(node, {
      asset,
      ast
    }, ancestors) {
      let {
        callee,
        arguments: args
      } = node;
      let isWebWorker = callee.type === 'Identifier' && (callee.name === 'Worker' || callee.name === 'SharedWorker') && !(0, _utils2.hasBinding)(ancestors, callee.name) && !(0, _utils2.isInFalsyBranch)(ancestors) && types.isStringLiteral(args[0]) && (args.length === 1 || args.length === 2);

      if (isWebWorker) {
        let isModule = false;

        if (types.isObjectExpression(args[1])) {
          let prop = args[1].properties.find(v => types.isIdentifier(v.key, {
            name: 'type'
          }));
          if (prop && types.isStringLiteral(prop.value)) isModule = prop.value.value === 'module';
        }

        addURLDependency(asset, ast, args[0], {
          env: {
            context: 'web-worker',
            outputFormat: isModule && asset.env.scopeHoist ? 'esmodule' : undefined
          },
          meta: {
            webworker: true
          }
        });
      }
    }

  }
}; // TypeScript, Rollup, and Parcel itself generate these patterns for async imports in CommonJS
//   1. TypeScript - Promise.resolve().then(function () { return require(...) })
//   2. Rollup - new Promise(function (resolve) { resolve(require(...)) })
//   3. Parcel - Promise.resolve(require(...))

exports.default = _default;

function isRequireAsync(ancestors, requireNode, asset, ast) {
  let parent = ancestors[ancestors.length - 2]; // Promise.resolve().then(() => require('foo'))
  // Promise.resolve().then(() => { return require('foo') })
  // Promise.resolve().then(function () { return require('foo') })

  let functionParent = getFunctionParent(ancestors);

  if (functionParent && (0, types.isCallExpression)(functionParent) && (0, types.isMemberExpression)(functionParent.callee) && functionParent.callee.property.name === 'then' && isPromiseResolve(functionParent.callee.object)) {
    // If the `require` call is not immediately returned (e.g. wrapped in another function),
    // then transform the AST to create a promise chain so that the require is by itself.
    // This is because the require will return a promise rather than the module synchronously.
    // For example, TypeScript generates the following with the esModuleInterop flag:
    //   Promise.resolve().then(() => __importStar(require('./foo')));
    // This is transformed into:
    //   Promise.resolve().then(() => require('./foo')).then(res => __importStar(res));
    if (!(0, types.isArrowFunctionExpression)(parent) && !(0, types.isReturnStatement)(parent)) {
      // Replace the original `require` call with a reference to a variable
      let requireClone = types.clone(requireNode);
      let v = types.identifier('$parcel$' + (0, _utils.md5FromString)(requireNode.arguments[0].value).slice(-4));
      (0, _utils2.morph)(requireNode, v); // Add the variable as a param to the parent function

      let fn = functionParent.arguments[0]; // $FlowFixMe

      fn.params[0] = v; // Replace original function with only the require call

      functionParent.arguments[0] = (0, types.isArrowFunctionExpression)(fn) ? types.arrowFunctionExpression([], requireClone) : types.functionExpression(null, [], types.blockStatement([types.returnStatement(requireClone)])); // Add the original function as an additional promise chain

      let replacement = types.callExpression(types.memberExpression(types.clone(functionParent), types.identifier('then')), [fn]);
      (0, _utils2.morph)(functionParent, replacement);
      asset.setAST(ast);
    }

    return true;
  } // Promise.resolve(require('foo'))
  // $FlowFixMe


  if (isPromiseResolve(parent) && parent.arguments[0] === requireNode) {
    return true;
  } // new Promise(resolve => resolve(require('foo')))
  // new Promise(resolve => { resolve(require('foo')) })
  // new Promise(function (resolve) { resolve(require('foo')) })


  if (functionParent && (0, types.isCallExpression)(parent) && (0, types.isIdentifier)(parent.callee) && (0, types.isNewExpression)(functionParent) && (0, types.isIdentifier)(functionParent.callee) && functionParent.callee.name === 'Promise' && (0, types.isFunction)(functionParent.arguments[0]) && // $FlowFixMe
  (0, types.isIdentifier)(functionParent.arguments[0].params[0]) && // $FlowFixMe
  parent.callee.name === functionParent.arguments[0].params[0].name) {
    return true;
  }
}

function isPromiseResolve(node) {
  return (0, types.isCallExpression)(node) && (0, types.isMemberExpression)(node.callee) && (0, types.isIdentifier)(node.callee.object) && (0, types.isIdentifier)(node.callee.property) && node.callee.object.name === 'Promise' && node.callee.property.name === 'resolve';
}

function getFunctionParent(ancestors) {
  for (let i = ancestors.length - 1; i >= 0; i--) {
    if (types.isFunction(ancestors[i])) {
      return ancestors[i - 1];
    }
  }
}

function addDependency(asset, node, opts) {
  asset.addDependency({
    moduleSpecifier: node.value,
    loc: node.loc && (0, _utils.createDependencyLocation)(node.loc.start, node.value, 0, 1),
    isAsync: opts ? opts.isAsync : false,
    isOptional: opts ? opts.isOptional : false
  });
}

function addURLDependency(asset, ast, node, opts = {}) {
  let url = node.value;
  asset.addURLDependency(url, {
    loc: node.loc && (0, _utils.createDependencyLocation)(node.loc.start, node.value, 0, 1),
    ...opts
  });
  (0, _utils2.morph)(node, types.callExpression(types.identifier('require'), [types.stringLiteral(url)]));
  asset.setAST(ast);
}