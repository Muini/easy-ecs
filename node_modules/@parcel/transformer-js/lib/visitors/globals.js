"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var types = _interopRequireWildcard(require("@babel/types"));

var _utils = require("./utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const VARS = {
  process: () => ({
    code: 'var process = require("process");',
    deps: ['process']
  }),
  global: asset => asset.env.scopeHoist ?
  /* Scope hoisting replaces this on its own in hoist.js */
  null : {
    code: `var global = arguments[3];`
  },
  __dirname: asset => ({
    code: `var __dirname = ${JSON.stringify(_path.default.dirname(asset.filePath))};`
  }),
  __filename: asset => ({
    code: `var __filename = ${JSON.stringify(asset.filePath)};`
  }),
  Buffer: () => ({
    code: 'var Buffer = require("buffer").Buffer;',
    deps: ['buffer']
  }),
  // Prevent AMD defines from working when loading UMD bundles.
  // Ideally the CommonJS check would come before the AMD check, but many
  // existing modules do the checks the opposite way leading to modules
  // not exporting anything to Parcel.
  define: () => ({
    code: 'var define;'
  })
};
var _default = {
  Identifier(node, context, ancestors) {
    let parent = ancestors[ancestors.length - 2];

    if (VARS.hasOwnProperty(node.name) && !context.globals.has(node.name) && types.isReferenced(node, parent) && !types.isModuleSpecifier(parent) && !(0, _utils.hasBinding)(ancestors, node.name) && !(0, _utils.isInFalsyBranch)(ancestors)) {
      context.globals.set(node.name, VARS[node.name](context.asset));
    }
  },

  Declaration(node, context, ancestors) {
    // If there is a global declaration of one of the variables, remove our declaration
    let identifiers = types.getBindingIdentifiers(node);

    for (let id in identifiers) {
      if (VARS.hasOwnProperty(id) && !inScope(ancestors)) {
        // Don't delete entirely, so we don't add it again when the declaration is referenced
        context.globals.set(id, null);
      }
    }
  },

  Program: {
    exit(node, context) {
      // Add dependencies at the end so that items that were deleted later don't leave
      // their dependencies around.
      for (let g of context.globals.values()) {
        if (g && g.deps) {
          for (let dep of g.deps) {
            context.asset.addDependency({
              moduleSpecifier: dep
            });
          }
        }
      }
    }

  }
};
exports.default = _default;

function inScope(ancestors) {
  for (let i = ancestors.length - 2; i >= 0; i--) {
    if (types.isScope(ancestors[i]) && !types.isProgram(ancestors[i])) {
      return true;
    }
  }

  return false;
}