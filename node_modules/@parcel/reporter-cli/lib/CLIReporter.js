"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._report = _report;
exports.default = void 0;

var _plugin = require("@parcel/plugin");

var _utils = require("@parcel/utils");

var _chalk = _interopRequireDefault(require("chalk"));

var _utils2 = require("./utils");

var _logLevels = _interopRequireDefault(require("./logLevels"));

var _bundleReport = _interopRequireDefault(require("./bundleReport"));

var _render = require("./render");

var emoji = _interopRequireWildcard(require("./emoji"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const THROTTLE_DELAY = 100;
let statusThrottle = (0, _utils.throttle)(message => {
  (0, _render.updateSpinner)(message);
}, THROTTLE_DELAY); // Exported only for test

async function _report(event, options) {
  let logLevelFilter = _logLevels.default[options.logLevel || 'info'];

  switch (event.type) {
    case 'buildStart':
      {
        if (logLevelFilter < _logLevels.default.info) {
          break;
        } // Clear any previous output


        (0, _render.resetWindow)();

        if (options.serve) {
          var _options$serve$host;

          (0, _render.persistMessage)(_chalk.default.blue.bold(`${emoji.info} Server running at ${options.serve.https ? 'https' : 'http'}://${(_options$serve$host = options.serve.host) !== null && _options$serve$host !== void 0 ? _options$serve$host : 'localhost'}:${options.serve.port}`));
        }

        break;
      }

    case 'buildProgress':
      {
        if (logLevelFilter < _logLevels.default.info) {
          break;
        }

        let message = (0, _utils2.getProgressMessage)(event);

        if (message != null) {
          if (_render.isTTY) {
            statusThrottle(_chalk.default.gray.bold(message));
          } else {
            (0, _render.updateSpinner)(message);
          }
        }

        break;
      }

    case 'buildSuccess':
      if (logLevelFilter < _logLevels.default.info) {
        break;
      }

      (0, _render.persistSpinner)('buildProgress', 'success', _chalk.default.green.bold(`Built in ${(0, _utils.prettifyTime)(event.buildTime)}`));

      if (options.mode === 'production') {
        await (0, _bundleReport.default)(event.bundleGraph, options.outputFS, options.projectRoot, options.detailedReport);
      }

      break;

    case 'buildFailure':
      if (logLevelFilter < _logLevels.default.error) {
        break;
      }

      (0, _render.resetWindow)();
      (0, _render.persistSpinner)('buildProgress', 'error', _chalk.default.red.bold('Build failed.'));
      await writeDiagnostic(options, event.diagnostics, 'red', true);
      break;

    case 'log':
      {
        if (logLevelFilter < _logLevels.default[event.level]) {
          break;
        }

        switch (event.level) {
          case 'success':
            (0, _render.writeOut)(_chalk.default.green(event.message));
            break;

          case 'progress':
            (0, _render.writeOut)(event.message);
            break;

          case 'verbose':
          case 'info':
            await writeDiagnostic(options, event.diagnostics, 'blue');
            break;

          case 'warn':
            await writeDiagnostic(options, event.diagnostics, 'yellow', true);
            break;

          case 'error':
            await writeDiagnostic(options, event.diagnostics, 'red', true);
            break;

          default:
            throw new Error('Unknown log level ' + event.level);
        }
      }
  }
}

async function writeDiagnostic(options, diagnostics, color, isError = false) {
  for (let diagnostic of diagnostics) {
    let {
      message,
      stack,
      codeframe,
      hints
    } = await (0, _utils.prettyDiagnostic)(diagnostic, options, (0, _utils2.getTerminalWidth)().columns);
    message = _chalk.default[color](message);

    if (message) {
      (0, _render.writeOut)(message, isError);
    }

    if (stack) {
      (0, _render.writeOut)(_chalk.default.gray(stack), isError);
    }

    if (codeframe) {
      (0, _render.writeOut)(codeframe, isError);
    } // Write hints


    for (let hint of hints) {
      (0, _render.writeOut)(_chalk.default.blue.bold(hint));
    }
  }
}

var _default = new _plugin.Reporter({
  report({
    event,
    options
  }) {
    return _report(event, options);
  }

});

exports.default = _default;