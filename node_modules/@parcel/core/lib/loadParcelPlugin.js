"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loadPlugin;

var _semver = _interopRequireDefault(require("semver"));

var _logger = _interopRequireDefault(require("@parcel/logger"));

var _plugin = require("@parcel/plugin");

var _nullthrows = _interopRequireDefault(require("nullthrows"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const PARCEL_VERSION = require('../package.json').version;

async function loadPlugin(packageManager, pluginName, resolveFrom, autoinstall) {
  let {
    resolved,
    pkg
  } = await packageManager.resolve(pluginName, `${resolveFrom}/index`, {
    autoinstall
  }); // Validate the engines.parcel field in the plugin's package.json

  let parcelVersionRange = pkg && pkg.engines && pkg.engines.parcel;

  if (!parcelVersionRange) {
    _logger.default.warn({
      origin: '@parcel/core',
      message: `The plugin "${pluginName}" needs to specify a \`package.json#engines.parcel\` field with the supported Parcel version range.`
    });
  }

  if (parcelVersionRange && !_semver.default.satisfies(PARCEL_VERSION, parcelVersionRange)) {
    throw new Error(`The plugin "${pluginName}" is not compatible with the current version of Parcel. Requires "${parcelVersionRange}" but the current version is "${PARCEL_VERSION}".`);
  }

  let plugin = await packageManager.require(resolved, `${resolveFrom}/index`, {
    autoinstall
  });
  plugin = plugin.default ? plugin.default : plugin;

  if (!plugin) {
    throw new Error(`Plugin ${pluginName} has no exports.`);
  }

  plugin = plugin[_plugin.CONFIG];

  if (!plugin) {
    throw new Error(`Plugin ${pluginName} is not a valid Parcel plugin, should export an instance of a Parcel plugin ex. "export default new Reporter({ ... })".`);
  }

  return {
    plugin,
    version: (0, _nullthrows.default)(pkg).version
  };
}