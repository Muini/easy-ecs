"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAsset = createAsset;
exports.generateFromAST = generateFromAST;
exports.getConfig = getConfig;

var _stream = require("stream");

var _logger = require("@parcel/logger");

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _CommittedAsset = _interopRequireDefault(require("./CommittedAsset"));

var _UncommittedAsset = _interopRequireDefault(require("./UncommittedAsset"));

var _loadParcelPlugin = _interopRequireDefault(require("./loadParcelPlugin"));

var _Asset = require("./public/Asset");

var _PluginOptions = _interopRequireDefault(require("./public/PluginOptions"));

var _utils = require("@parcel/utils");

var _Environment = require("./Environment");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createAsset(options) {
  var _options$committed, _options$isIsolated, _options$isInline, _options$symbols, _options$sideEffects;

  let idBase = options.idBase != null ? options.idBase : options.filePath;
  let uniqueKey = options.uniqueKey || '';
  return {
    id: options.id != null ? options.id : (0, _utils.md5FromString)(idBase + options.type + (0, _Environment.getEnvironmentHash)(options.env) + uniqueKey),
    committed: (_options$committed = options.committed) !== null && _options$committed !== void 0 ? _options$committed : false,
    hash: options.hash,
    filePath: options.filePath,
    isIsolated: (_options$isIsolated = options.isIsolated) !== null && _options$isIsolated !== void 0 ? _options$isIsolated : false,
    isInline: (_options$isInline = options.isInline) !== null && _options$isInline !== void 0 ? _options$isInline : false,
    isSplittable: options.isSplittable,
    type: options.type,
    contentKey: options.contentKey,
    mapKey: options.mapKey,
    astKey: options.astKey,
    astGenerator: options.astGenerator,
    dependencies: options.dependencies || new Map(),
    includedFiles: options.includedFiles || new Map(),
    isSource: options.isSource,
    outputHash: options.outputHash,
    pipeline: options.pipeline,
    env: options.env,
    meta: options.meta || {},
    stats: options.stats,
    symbols: (_options$symbols = options.symbols) !== null && _options$symbols !== void 0 ? _options$symbols : options.symbols === null ? null : new Map(),
    sideEffects: (_options$sideEffects = options.sideEffects) !== null && _options$sideEffects !== void 0 ? _options$sideEffects : true,
    uniqueKey: uniqueKey,
    plugin: options.plugin,
    configPath: options.configPath
  };
}

const generateResults = new WeakMap();

function generateFromAST(asset) {
  let output = generateResults.get(asset.value);

  if (output == null) {
    output = _generateFromAST(asset);
    generateResults.set(asset.value, output);
  }

  return output;
}

async function _generateFromAST(asset) {
  let ast = await asset.getAST();

  if (ast == null) {
    throw new Error('Asset has no AST');
  }

  let pluginName = (0, _nullthrows.default)(asset.value.plugin);
  let {
    plugin
  } = await (0, _loadParcelPlugin.default)(asset.options.packageManager, pluginName, (0, _nullthrows.default)(asset.value.configPath), asset.options.autoinstall);

  if (!plugin.generate) {
    throw new Error(`${pluginName} does not have a generate method`);
  }

  let {
    content,
    map
  } = await plugin.generate({
    asset: new _Asset.Asset(asset),
    ast,
    options: new _PluginOptions.default(asset.options),
    logger: new _logger.PluginLogger({
      origin: pluginName
    })
  });
  let mapBuffer = map === null || map === void 0 ? void 0 : map.toBuffer(); // Store the results in the cache so we can avoid generating again next time

  await Promise.all([asset.options.cache.setStream((0, _nullthrows.default)(asset.value.contentKey), (0, _utils.blobToStream)(content)), mapBuffer != null && asset.options.cache.setBlob((0, _nullthrows.default)(asset.value.mapKey), mapBuffer)]);
  return {
    content: content instanceof _stream.Readable ? asset.options.cache.getStream((0, _nullthrows.default)(asset.value.contentKey)) : content,
    map
  };
}

async function getConfig(asset, filePaths, options) {
  let packageKey = options === null || options === void 0 ? void 0 : options.packageKey;
  let parse = options && options.parse;

  if (packageKey != null) {
    let pkg = await asset.getPackage();

    if (pkg && pkg[packageKey]) {
      return {
        config: pkg[packageKey],
        // The package.json file was already registered by asset.getPackage() -> asset.getConfig()
        files: []
      };
    }
  }

  let conf = await (0, _utils.loadConfig)(asset.options.inputFS, asset.value.filePath, filePaths, parse == null ? null : {
    parse
  });

  if (!conf) {
    return null;
  }

  return conf;
}