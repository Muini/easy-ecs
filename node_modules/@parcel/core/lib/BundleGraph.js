"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeAssetGroups = removeAssetGroups;
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _crypto = _interopRequireDefault(require("crypto"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _utils = require("@parcel/utils");

var _utils2 = require("./utils");

var _Graph = _interopRequireWildcard(require("./Graph"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class BundleGraph {
  // TODO: These hashes are being invalidated in mutative methods, but this._graph is not a private
  // property so it is possible to reach in and mutate the graph without invalidating these hashes.
  // It needs to be exposed in BundlerRunner for now based on how applying runtimes works and the
  // BundlerRunner takes care of invalidating hashes when runtimes are applied, but this is not ideal.
  constructor({
    graph,
    bundleContentHashes
  }) {
    _defineProperty(this, "_bundleContentHashes", void 0);

    _defineProperty(this, "_graph", void 0);

    this._graph = graph;
    this._bundleContentHashes = bundleContentHashes || new Map();
  }

  static deserialize(opts) {
    return new BundleGraph({
      graph: opts._graph,
      bundleContentHashes: opts._bundleContentHashes
    });
  }

  addAssetGraphToBundle(asset, bundle) {
    // The root asset should be reached directly from the bundle in traversal.
    // Its children will be traversed from there.
    this._graph.addEdge(bundle.id, asset.id);

    this._graph.traverse((node, _, actions) => {
      if (node.type === 'bundle_group') {
        actions.skipChildren();
        return;
      }

      if (node.type === 'asset' && !this.bundleHasAsset(bundle, node.value)) {
        bundle.stats.size += node.value.stats.size;
      }

      if (node.type === 'asset' || node.type === 'dependency') {
        this._graph.addEdge(bundle.id, node.id, 'contains');
      }

      if (node.type === 'dependency') {
        for (let bundleGroupNode of this._graph.getNodesConnectedFrom(node).filter(node => node.type === 'bundle_group')) {
          this._graph.addEdge(bundle.id, bundleGroupNode.id, 'bundle');
        }
      }
    }, (0, _nullthrows.default)(this._graph.getNode(asset.id)));

    this._bundleContentHashes.delete(bundle.id);
  }

  internalizeAsyncDependency(bundle, dependency) {
    if (!dependency.isAsync) {
      throw new Error('Expected an async dependency');
    }

    this._graph.addEdge(bundle.id, dependency.id, 'internal_async');

    this.removeExternalDependency(bundle, dependency);
  }

  isDependencyDeferred(dependency) {
    let node = this._graph.getNode(dependency.id);

    (0, _assert.default)(node && node.type === 'dependency');
    return !!node.hasDeferred;
  }

  getParentBundlesOfBundleGroup(bundleGroup) {
    return this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode((0, _utils2.getBundleGroupId)(bundleGroup))), 'bundle').filter(node => node.type === 'bundle').map(node => {
      (0, _assert.default)(node.type === 'bundle');
      return node.value;
    });
  }

  resolveExternalDependency(dependency, bundle) {
    if (bundle != null && this._graph.hasEdge(bundle.id, dependency.id, 'internal_async')) {
      let resolved = this.getDependencyResolution(dependency, bundle);

      if (resolved == null) {
        return;
      } else {
        return {
          type: 'asset',
          value: resolved
        };
      }
    }

    let node = this._graph.getNodesConnectedFrom((0, _nullthrows.default)(this._graph.getNode(dependency.id))).find(node => node.type === 'bundle_group');

    if (node == null) {
      return;
    }

    (0, _assert.default)(node.type === 'bundle_group');
    return {
      type: 'bundle_group',
      value: node.value
    };
  }

  removeAssetGraphFromBundle(asset, bundle) {
    // Remove all contains edges from the bundle to the nodes in the asset's
    // subgraph.
    this._graph.traverse((node, context, actions) => {
      if (node.type === 'bundle_group') {
        actions.skipChildren();
        return;
      }

      if (node.type === 'asset' || node.type === 'dependency') {
        if (this._graph.hasEdge(bundle.id, node.id, 'contains')) {
          this._graph.removeEdge(bundle.id, node.id, 'contains', // Removing this contains edge should not orphan the connected node. This
          // is disabled for performance reasons as these edges are removed as part
          // of a traversal, and checking for orphans becomes quite expensive in
          // aggregate.
          false
          /* removeOrphans */
          );

          if (node.type === 'asset') {
            bundle.stats.size -= asset.stats.size;
          }
        } else {
          actions.skipChildren();
        }
      }

      if (node.type === 'dependency') {
        this.removeExternalDependency(bundle, node.value);
      }
    }, (0, _nullthrows.default)(this._graph.getNode(asset.id))); // Remove the untyped edge from the bundle to the entry.


    if (this._graph.hasEdge(bundle.id, asset.id)) {
      this._graph.removeEdge(bundle.id, asset.id);
    }

    this._bundleContentHashes.delete(bundle.id);
  }

  removeExternalDependency(bundle, dependency) {
    for (let bundleGroupNode of this._graph.getNodesConnectedFrom((0, _nullthrows.default)(this._graph.getNode(dependency.id))).filter(node => node.type === 'bundle_group')) {
      let inboundDependencies = this._graph.getNodesConnectedTo(bundleGroupNode).filter(node => node.type === 'dependency').map(node => {
        (0, _assert.default)(node.type === 'dependency');
        return node.value;
      }); // If every inbound dependency to this bundle group does not belong to this bundle,
      // or the dependency is internal to the bundle, then the connection between
      // this bundle and the group is safe to remove.


      if (inboundDependencies.every(dependency => !this.bundleHasDependency(bundle, dependency) || this._graph.hasEdge(bundle.id, dependency.id, 'internal_async'))) {
        this._graph.removeEdge(bundle.id, bundleGroupNode.id, 'bundle');
      }
    }
  }

  createAssetReference(dependency, asset) {
    this._graph.addEdge(dependency.id, asset.id, 'references');

    if (this._graph.hasEdge(dependency.id, asset.id)) {
      this._graph.removeEdge(dependency.id, asset.id);
    }
  }

  createBundleReference(from, to) {
    this._graph.addEdge(from.id, to.id, 'references');
  }

  findBundlesWithAsset(asset) {
    return this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode(asset.id)), 'contains').filter(node => node.type === 'bundle').map(node => {
      (0, _assert.default)(node.type === 'bundle');
      return node.value;
    });
  }

  findBundlesWithDependency(dependency) {
    return this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode(dependency.id)), 'contains').filter(node => node.type === 'bundle').map(node => {
      (0, _assert.default)(node.type === 'bundle');
      return node.value;
    });
  }

  getDependencyAssets(dependency) {
    let dependencyNode = (0, _nullthrows.default)(this._graph.getNode(dependency.id));
    return this._graph.getNodesConnectedFrom(dependencyNode).filter(node => node.type === 'asset').map(node => {
      (0, _assert.default)(node.type === 'asset');
      return node.value;
    });
  }

  getDependencyResolution(dep, bundle) {
    let depNode = this._graph.getNode(dep.id);

    if (!depNode) {
      return null;
    }

    let assets = this.getDependencyAssets(dep);
    let firstAsset = assets[0];
    let resolved = // If no bundle is specified, use the first concrete asset.
    bundle == null ? firstAsset : // Otherwise, find the first asset that belongs to this bundle.
    assets.find(asset => this.bundleHasAsset(bundle, asset)) || firstAsset; // If a resolution still hasn't been found, return the first referenced asset.

    if (resolved == null) {
      this._graph.traverse((node, _, traversal) => {
        if (node.type === 'asset') {
          resolved = node.value;
          traversal.stop();
        } else if (node.id !== dep.id) {
          traversal.skipChildren();
        }
      }, depNode, 'references');
    }

    return resolved;
  }

  getDependencies(asset) {
    let node = this._graph.getNode(asset.id);

    if (!node) {
      throw new Error('Asset not found');
    }

    return this._graph.getNodesConnectedFrom(node).map(node => {
      (0, _assert.default)(node.type === 'dependency');
      return node.value;
    });
  }

  traverseAssets(bundle, visit) {
    return this.traverseBundle(bundle, (0, _Graph.mapVisitor)(node => node.type === 'asset' ? node.value : null, visit));
  }

  isAssetReferenced(asset) {
    return this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode(asset.id)), 'references').length > 0;
  }

  isAssetReferencedByDependant(bundle, asset, visitedBundles = new Set()) {
    let dependencies = this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode(asset.id))).filter(node => node.type === 'dependency').map(node => {
      (0, _assert.default)(node.type === 'dependency');
      return node.value;
    });

    const bundleHasReference = bundle => {
      return !this.bundleHasAsset(bundle, asset) && dependencies.some(dependency => this.bundleHasDependency(bundle, dependency));
    };

    let isReferenced = false;
    this.traverseBundles((descendant, _, actions) => {
      if (visitedBundles.has(descendant)) {
        actions.skipChildren();
        return;
      }

      visitedBundles.add(descendant);

      if (descendant.type !== bundle.type || descendant.env.context !== bundle.env.context) {
        actions.skipChildren();
        return;
      }

      if (descendant !== bundle && bundleHasReference(descendant)) {
        isReferenced = true;
        actions.stop();
        return;
      }

      let similarSiblings = this.getSiblingBundles(descendant).filter(sibling => sibling.type === bundle.type && sibling.env.context === bundle.env.context);

      if (similarSiblings.some(sibling => bundleHasReference(sibling) || this.isAssetReferencedByDependant(sibling, asset, visitedBundles))) {
        isReferenced = true;
        actions.stop();
      }
    }, bundle);
    return isReferenced;
  }

  hasParentBundleOfType(bundle, type) {
    let parents = this.getParentBundles(bundle);
    return parents.length > 0 && parents.every(parent => parent.type === type);
  }

  getParentBundles(bundle) {
    return (0, _utils.flatMap)(this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode(bundle.id)), 'bundle'), bundleGroupNode => this._graph.getNodesConnectedTo(bundleGroupNode, 'bundle') // Entry bundle groups have the root node as their parent
    .filter(node => node.type !== 'root')).map(node => {
      (0, _assert.default)(node.type === 'bundle');
      return node.value;
    });
  }

  isAssetReachableFromBundle(asset, bundle) {
    // For an asset to be reachable from a bundle, it must either exist in a sibling bundle,
    // or in an ancestor bundle group reachable from all parent bundles.
    let bundleGroups = this.getBundleGroupsContainingBundle(bundle);
    return bundleGroups.every(bundleGroup => {
      // If the asset is in any sibling bundles of the original bundle, it is reachable.
      let bundles = this.getBundlesInBundleGroup(bundleGroup);

      if (bundles.some(b => b.id !== bundle.id && this.bundleHasAsset(b, asset))) {
        return true;
      } // Get a list of parent bundle nodes pointing to the bundle group


      let parentBundleNodes = this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode((0, _utils2.getBundleGroupId)(bundleGroup))), 'bundle'); // Check that every parent bundle has a bundle group in its ancestry that contains the asset.


      return parentBundleNodes.every(bundleNode => {
        let inBundle = false;

        this._graph.traverseAncestors(bundleNode, (node, ctx, actions) => {
          if (node.type === 'bundle_group') {
            let childBundles = this.getBundlesInBundleGroup(node.value);

            if (childBundles.some(b => b.id !== bundle.id && this.bundleHasAsset(b, asset))) {
              inBundle = true;
              actions.stop();
            }
          } // Don't deduplicate when context changes


          if (node.type === 'bundle' && node.value.env.context !== bundle.env.context) {
            actions.skipChildren();
          }
        }, 'bundle');

        return inBundle;
      });
    });
  }

  findReachableBundleWithAsset(bundle, asset) {
    let bundleGroups = this.getBundleGroupsContainingBundle(bundle);

    for (let bundleGroup of bundleGroups) {
      // If the asset is in any sibling bundles, return that bundle.
      let bundles = this.getBundlesInBundleGroup(bundleGroup);
      let res = bundles.find(b => b.id !== bundle.id && this.bundleHasAsset(b, asset));

      if (res != null) {
        return res;
      } // Get a list of parent bundle nodes pointing to the bundle group


      let parentBundleNodes = this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode((0, _utils2.getBundleGroupId)(bundleGroup))), 'bundle'); // Find the nearest ancestor bundle that includes the asset.


      for (let bundleNode of parentBundleNodes) {
        this._graph.traverseAncestors(bundleNode, (node, ctx, actions) => {
          if (node.type === 'bundle_group') {
            let childBundles = this.getBundlesInBundleGroup(node.value);
            res = childBundles.find(b => b.id !== bundle.id && this.bundleHasAsset(b, asset));

            if (res != null) {
              actions.stop();
            }
          } // Stop when context changes


          if (node.type === 'bundle' && node.value.env.context !== bundle.env.context) {
            actions.skipChildren();
          }
        }, 'bundle');

        if (res != null) {
          return res;
        }
      }
    }
  }

  traverseBundle(bundle, visit) {
    let entries = true; // A modified DFS traversal which traverses entry assets in the same order
    // as their ids appear in `bundle.entryAssetIds`.

    return this._graph.dfs({
      visit: (0, _Graph.mapVisitor)((node, actions) => {
        if (node.id === bundle.id) {
          return;
        }

        if (node.type === 'dependency' || node.type === 'asset') {
          if (this._graph.hasEdge(bundle.id, node.id, 'contains')) {
            return node;
          }
        }

        actions.skipChildren();
      }, visit),
      startNode: (0, _nullthrows.default)(this._graph.getNode(bundle.id)),
      getChildren: node => {
        let children = this._graph.getNodesConnectedFrom((0, _nullthrows.default)(node));

        let sorted = entries && bundle.entryAssetIds.length > 0 ? children.sort((a, b) => {
          let aIndex = bundle.entryAssetIds.indexOf(a.id);
          let bIndex = bundle.entryAssetIds.indexOf(b.id);

          if (aIndex === bIndex) {
            // If both don't exist in the entry asset list, or
            // otherwise have the same index.
            return 0;
          } else if (aIndex === -1) {
            return 1;
          } else if (bIndex === -1) {
            return -1;
          }

          return aIndex - bIndex;
        }) : children;
        entries = false;
        return sorted;
      }
    });
  }

  traverseContents(visit) {
    return this._graph.filteredTraverse(node => node.type === 'asset' || node.type === 'dependency' ? node : null, visit);
  }

  getChildBundles(bundle) {
    let bundles = [];
    this.traverseBundles((b, _, actions) => {
      if (bundle.id === b.id) {
        return;
      }

      bundles.push(b);
      actions.skipChildren();
    }, bundle);
    return bundles;
  }

  traverseBundles(visit, startBundle) {
    return this._graph.filteredTraverse(node => node.type === 'bundle' ? node.value : null, visit, startBundle ? (0, _nullthrows.default)(this._graph.getNode(startBundle.id)) : null, 'bundle');
  }

  getBundles() {
    let bundles = [];
    this.traverseBundles(bundle => {
      bundles.push(bundle);
    });
    return bundles;
  }

  getTotalSize(asset) {
    let size = 0;

    this._graph.traverse((node, _, actions) => {
      if (node.type === 'bundle_group') {
        actions.skipChildren();
        return;
      }

      if (node.type === 'asset') {
        size += node.value.stats.size;
      }
    }, (0, _nullthrows.default)(this._graph.getNode(asset.id)));

    return size;
  }

  getBundleGroupsContainingBundle(bundle) {
    return this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode(bundle.id)), 'bundle').filter(node => node.type === 'bundle_group').map(node => {
      (0, _assert.default)(node.type === 'bundle_group');
      return node.value;
    });
  }

  getBundlesInBundleGroup(bundleGroup) {
    return this._graph.getNodesConnectedFrom((0, _nullthrows.default)(this._graph.getNode((0, _utils2.getBundleGroupId)(bundleGroup))), 'bundle').filter(node => node.type === 'bundle').map(node => {
      (0, _assert.default)(node.type === 'bundle');
      return node.value;
    });
  }

  getSiblingBundles(bundle) {
    let siblings = [];
    let bundleGroups = this.getBundleGroupsContainingBundle(bundle);

    for (let bundleGroup of bundleGroups) {
      let bundles = this.getBundlesInBundleGroup(bundleGroup);

      for (let b of bundles) {
        if (b.id !== bundle.id) {
          siblings.push(b);
        }
      }
    }

    return siblings;
  }

  getReferencedBundles(bundle) {
    let bundles = [];

    this._graph.traverse((node, _, traversal) => {
      if (node.type === 'bundle') {
        bundles.push(node.value);
        traversal.stop();
      } else if (node.id !== bundle.id) {
        traversal.skipChildren();
      }
    }, (0, _nullthrows.default)(this._graph.getNode(bundle.id)), 'references');

    return bundles;
  }

  getIncomingDependencies(asset) {
    let node = this._graph.getNode(asset.id);

    if (!node) {
      return [];
    }

    return this._graph.findAncestors(node, node => node.type === 'dependency').map(node => {
      (0, _assert.default)(node.type === 'dependency');
      return node.value;
    });
  }

  bundleHasAsset(bundle, asset) {
    return this._graph.hasEdge(bundle.id, asset.id, 'contains');
  }

  bundleHasDependency(bundle, dependency) {
    return this._graph.hasEdge(bundle.id, dependency.id, 'contains');
  }

  filteredTraverse(bundle, filter, visit) {
    return this._graph.filteredTraverse(filter, visit, (0, _nullthrows.default)(this._graph.getNode(bundle.id)));
  }

  resolveSymbol(asset, symbol, boundary) {
    var _asset$symbols, _asset$symbols$get;

    let assetOutside = boundary && !this.bundleHasAsset(boundary, asset);
    let identifier = (_asset$symbols = asset.symbols) === null || _asset$symbols === void 0 ? void 0 : (_asset$symbols$get = _asset$symbols.get(symbol)) === null || _asset$symbols$get === void 0 ? void 0 : _asset$symbols$get.local;

    if (symbol === '*') {
      var _asset$symbols2, _asset$symbols2$get;

      return {
        asset,
        exportSymbol: '*',
        symbol: identifier !== null && identifier !== void 0 ? identifier : null,
        loc: (_asset$symbols2 = asset.symbols) === null || _asset$symbols2 === void 0 ? void 0 : (_asset$symbols2$get = _asset$symbols2.get(symbol)) === null || _asset$symbols2$get === void 0 ? void 0 : _asset$symbols2$get.loc
      };
    }

    let bailout = !asset.symbols;
    let deps = this.getDependencies(asset).reverse();
    let potentialResults = [];

    for (let dep of deps) {
      var _dep$symbols$get;

      // If this is a re-export, find the original module.
      let symbolLookup = new Map([...dep.symbols].map(([key, val]) => [val.local, key]));
      let depSymbol = symbolLookup.get(identifier);

      if (depSymbol != null) {
        let resolved = this.getDependencyResolution(dep);

        if (!resolved) {
          // External module
          bailout = true;
          break;
        }

        if (assetOutside) {
          // We found the symbol, but `asset` is outside, return `asset` and the original symbol
          bailout = true;
          break;
        }

        let {
          asset: resolvedAsset,
          symbol: resolvedSymbol,
          exportSymbol,
          loc
        } = this.resolveSymbol(resolved, depSymbol, boundary);

        if (!loc) {
          var _asset$symbols3, _asset$symbols3$get;

          // Remember how we got there
          loc = (_asset$symbols3 = asset.symbols) === null || _asset$symbols3 === void 0 ? void 0 : (_asset$symbols3$get = _asset$symbols3.get(symbol)) === null || _asset$symbols3$get === void 0 ? void 0 : _asset$symbols3$get.loc;
        }

        return {
          asset: resolvedAsset,
          symbol: resolvedSymbol,
          exportSymbol,
          loc
        };
      } // If this module exports wildcards, resolve the original module.
      // Default exports are excluded from wildcard exports.


      if (((_dep$symbols$get = dep.symbols.get('*')) === null || _dep$symbols$get === void 0 ? void 0 : _dep$symbols$get.local) === '*' && symbol !== 'default') {
        let resolved = this.getDependencyResolution(dep);
        if (!resolved) continue;
        let result = this.resolveSymbol(resolved, symbol, boundary); // Either result.symbol is a string (found) or null with a wildcard (found)

        if (result.symbol != undefined || result.symbol === null && result.exportSymbol === '*') {
          var _resolved$symbols, _resolved$symbols$get;

          if (assetOutside) {
            // We found the symbol, but `asset` is outside, return `asset` and the original symbol
            bailout = true;
            break;
          }

          return {
            asset: result.asset,
            symbol: result.symbol,
            exportSymbol: result.exportSymbol,
            loc: (_resolved$symbols = resolved.symbols) === null || _resolved$symbols === void 0 ? void 0 : (_resolved$symbols$get = _resolved$symbols.get(symbol)) === null || _resolved$symbols$get === void 0 ? void 0 : _resolved$symbols$get.loc
          };
        }

        if (!result.asset.symbols) {
          var _resolved$symbols2, _resolved$symbols2$ge;

          // We didn't find it in this dependency, but it might still be there: bailout.
          // Continue searching though, with the assumption that there are no conficting reexports
          // and there might be a another (re)export (where we might statically find the symbol).
          potentialResults.push({
            asset: result.asset,
            symbol: result.symbol,
            exportSymbol: result.exportSymbol,
            loc: (_resolved$symbols2 = resolved.symbols) === null || _resolved$symbols2 === void 0 ? void 0 : (_resolved$symbols2$ge = _resolved$symbols2.get(symbol)) === null || _resolved$symbols2$ge === void 0 ? void 0 : _resolved$symbols2$ge.loc
          });
          bailout = true;
        }
      }
    } // We didn't find the exact symbol...


    if (potentialResults.length == 1) {
      // ..., but if it does exist, it's has to be behind this one reexport.
      return potentialResults[0];
    } else {
      var _asset$symbols4, _asset$symbols4$get;

      // ... and there is no single reexport, but `bailout` tells us if it might still be exported.
      return {
        asset,
        exportSymbol: symbol,
        symbol: identifier !== null && identifier !== void 0 ? identifier : bailout ? null : undefined,
        loc: (_asset$symbols4 = asset.symbols) === null || _asset$symbols4 === void 0 ? void 0 : (_asset$symbols4$get = _asset$symbols4.get(symbol)) === null || _asset$symbols4$get === void 0 ? void 0 : _asset$symbols4$get.loc
      };
    }
  }

  getExportedSymbols(asset) {
    if (!asset.symbols) {
      return [];
    }

    let symbols = [];

    for (let symbol of asset.symbols.keys()) {
      symbols.push({ ...this.resolveSymbol(asset, symbol),
        exportAs: symbol
      });
    }

    let deps = this.getDependencies(asset);

    for (let dep of deps) {
      var _dep$symbols$get2;

      if (((_dep$symbols$get2 = dep.symbols.get('*')) === null || _dep$symbols$get2 === void 0 ? void 0 : _dep$symbols$get2.local) === '*') {
        let resolved = this.getDependencyResolution(dep);
        if (!resolved) continue;
        let exported = this.getExportedSymbols(resolved).filter(s => s.exportSymbol !== 'default').map(s => ({ ...s,
          exportAs: s.exportSymbol
        }));
        symbols.push(...exported);
      }
    }

    return symbols;
  }

  getContentHash(bundle) {
    let existingHash = this._bundleContentHashes.get(bundle.id);

    if (existingHash != null) {
      return existingHash;
    }

    let hash = _crypto.default.createHash('md5'); // TODO: sort??


    this.traverseAssets(bundle, asset => {
      hash.update([asset.outputHash, asset.filePath, asset.type, asset.uniqueKey].join(':'));
    });
    let hashHex = hash.digest('hex');

    this._bundleContentHashes.set(bundle.id, hashHex);

    return hashHex;
  }

  getHash(bundle) {
    let hash = _crypto.default.createHash('md5');

    this.traverseBundles((childBundle, ctx, traversal) => {
      if (childBundle.id === bundle.id || childBundle.isInline) {
        hash.update(this.getContentHash(childBundle));
      } else {
        hash.update(childBundle.id);
        traversal.skipChildren();
      }

      return {
        parentBundle: childBundle.id
      };
    }, bundle);
    hash.update(JSON.stringify((0, _utils.objectSortedEntriesDeep)(bundle.env)));
    return hash.digest('hex');
  }

}

exports.default = BundleGraph;

function removeAssetGroups(assetGraph) {
  let graph = new _Graph.default();
  let rootNode = assetGraph.getRootNode();
  (0, _assert.default)(rootNode != null && rootNode.type === 'root');
  graph.setRootNode(rootNode);
  let assetGroupIds = new Set();

  for (let [, node] of assetGraph.nodes) {
    if (node.type === 'asset_group') {
      assetGroupIds.add(node.id);
    } else {
      graph.addNode(node);
    }
  }

  for (let edge of assetGraph.getAllEdges()) {
    let fromIds;

    if (assetGroupIds.has(edge.from)) {
      fromIds = [...assetGraph.inboundEdges.get(edge.from).get(null)];
    } else {
      fromIds = [edge.from];
    }

    for (let from of fromIds) {
      if (assetGroupIds.has(edge.to)) {
        for (let to of assetGraph.outboundEdges.get(edge.to).get(null)) {
          graph.addEdge(from, to);
        }
      } else {
        graph.addEdge(from, edge.to);
      }
    }
  }

  return graph;
}