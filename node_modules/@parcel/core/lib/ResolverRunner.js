"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _logger = require("@parcel/logger");

var _utils = require("@parcel/utils");

var _diagnostic = _interopRequireWildcard(require("@parcel/diagnostic"));

var _path = _interopRequireDefault(require("path"));

var _url = _interopRequireDefault(require("url"));

var _ReporterRunner = require("./ReporterRunner");

var _Dependency = _interopRequireDefault(require("./public/Dependency"));

var _PluginOptions = _interopRequireDefault(require("./public/PluginOptions"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class ResolverRunner {
  constructor({
    config,
    options
  }) {
    _defineProperty(this, "config", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "pluginOptions", void 0);

    this.config = config;
    this.options = options;
    this.pluginOptions = new _PluginOptions.default(this.options);
  }

  async getThrowableDiagnostic(dependency, message) {
    let diagnostic = {
      message,
      origin: '@parcel/core'
    };

    if (dependency.loc && dependency.sourcePath) {
      diagnostic.filePath = dependency.sourcePath;
      diagnostic.codeFrame = {
        code: await this.options.inputFS.readFile(dependency.sourcePath, 'utf8'),
        codeHighlights: dependency.loc ? [{
          start: dependency.loc.start,
          end: dependency.loc.end
        }] : []
      };
    }

    return new _diagnostic.default({
      diagnostic
    });
  }

  async resolve(dependency) {
    let dep = new _Dependency.default(dependency);
    (0, _ReporterRunner.report)({
      type: 'buildProgress',
      phase: 'resolving',
      dependency: dep
    });
    let resolvers = await this.config.getResolvers();
    let pipeline;
    let filePath;
    let validPipelines = new Set(this.config.getNamedPipelines());

    if ( // Don't consider absolute paths. Absolute paths are only supported for entries,
    // and include e.g. `C:\` on Windows, conflicting with pipelines.
    !_path.default.isAbsolute(dependency.moduleSpecifier) && dependency.moduleSpecifier.includes(':')) {
      [pipeline, filePath] = dependency.moduleSpecifier.split(':');

      if (!validPipelines.has(pipeline)) {
        if (dep.isURL) {
          // This may be a url protocol or scheme rather than a pipeline, such as
          // `url('http://example.com/foo.png')`
          return null;
        } else {
          throw new Error(`Unknown pipeline ${pipeline}.`);
        }
      }
    } else {
      if (dependency.isURL && dependency.moduleSpecifier.startsWith('//')) {
        // A protocol-relative URL, e.g `url('//example.com/foo.png')`
        return null;
      }

      filePath = dependency.moduleSpecifier;
    }

    if (dependency.isURL) {
      let parsed = _url.default.parse(filePath);

      if (typeof parsed.pathname !== 'string') {
        throw new Error(`Received URL without a pathname ${filePath}.`);
      }

      filePath = decodeURIComponent(parsed.pathname);

      if (!pipeline) {
        pipeline = 'url';
      }
    }

    let errors = [];

    for (let resolver of resolvers) {
      try {
        let result = await resolver.plugin.resolve({
          filePath,
          dependency: dep,
          options: this.pluginOptions,
          logger: new _logger.PluginLogger({
            origin: resolver.name
          })
        });

        if (result && result.isExcluded) {
          return null;
        }

        if (result && result.filePath) {
          var _pipeline;

          return {
            filePath: result.filePath,
            sideEffects: result.sideEffects,
            code: result.code,
            env: dependency.env,
            pipeline: (_pipeline = pipeline) !== null && _pipeline !== void 0 ? _pipeline : dependency.pipeline
          };
        }
      } catch (e) {
        // Add error to error map, we'll append these to the standard error if we can't resolve the asset
        errors.push(new _diagnostic.default({
          diagnostic: (0, _diagnostic.errorToDiagnostic)(e, resolver.name)
        }));
      }
    }

    if (dep.isOptional) {
      return null;
    }

    let dir = dependency.sourcePath ? (0, _utils.escapeMarkdown)((0, _utils.relativePath)(this.options.projectRoot, dependency.sourcePath)) : '';
    let specifier = (0, _utils.escapeMarkdown)(dependency.moduleSpecifier || '');
    let err = await this.getThrowableDiagnostic(dependency, `Failed to resolve '${specifier}' ${dir ? `from '${dir}'` : ''}`); // Merge resolver errors

    if (errors.length) {
      for (let error of errors) {
        err.diagnostics.push(...error.diagnostics);
      }
    }

    err.code = 'MODULE_NOT_FOUND';
    throw err;
  }

}

exports.default = ResolverRunner;