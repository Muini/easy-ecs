"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _RequestTracker = require("../RequestTracker");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class AssetRequestRunner extends _RequestTracker.RequestRunner {
  constructor(opts) {
    super(opts);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "optionsRef", void 0);

    _defineProperty(this, "configRef", void 0);

    _defineProperty(this, "runTransform", void 0);

    _defineProperty(this, "assetGraph", void 0);

    this.type = 'asset_request';
    this.options = opts.options;
    this.optionsRef = opts.optionsRef;
    this.configRef = opts.configRef;
    this.runTransform = opts.workerFarm.createHandle('runTransform');
    this.assetGraph = opts.assetGraph;
  }

  async run(request, api) {
    api.invalidateOnFileUpdate((await this.options.inputFS.realpath(request.filePath)));
    let start = Date.now();
    let {
      assets,
      configRequests
    } = await this.runTransform({
      request: request,
      optionsRef: this.optionsRef,
      configRef: this.configRef
    });
    let time = Date.now() - start;

    for (let asset of assets) {
      asset.stats.time = time;
    }

    return {
      assets,
      configRequests
    };
  }

  onComplete(request, result, api) {
    this.assetGraph.resolveAssetGroup(request, result.assets, api.getId());
    let {
      assets,
      configRequests
    } = result;

    for (let asset of assets) {
      for (let filePath of asset.includedFiles.keys()) {
        api.invalidateOnFileUpdate(filePath);
        api.invalidateOnFileDelete(filePath);
      }
    } // TODO: this should no longer be needed once we have ConfigRequestRunner


    let graph = this.tracker.graph;
    let subrequestNodes = []; // Add config requests

    for (let {
      request,
      result
    } of configRequests) {
      let id = (0, _RequestTracker.generateRequestId)('config_request', request);
      let shouldSetupInvalidations = graph.invalidNodeIds.has(id) || !graph.hasNode(id);
      let subrequestNode = (0, _nullthrows.default)(graph.addRequest({
        id,
        type: 'config_request',
        request,
        result
      }));
      (0, _assert.default)(subrequestNode.type === 'request');

      if (shouldSetupInvalidations) {
        for (let filePath of result.includedFiles) {
          graph.invalidateOnFileUpdate(subrequestNode.id, filePath);
        }

        if (result.watchGlob != null) {
          graph.invalidateOnFileCreate(subrequestNode.id, result.watchGlob);
        }

        if (result.shouldInvalidateOnStartup) {
          graph.invalidateOnStartup(subrequestNode.id);
        }
      }

      subrequestNodes.push(subrequestNode); // Add dep version requests

      for (let [moduleSpecifier, version] of result.devDeps) {
        let depVersionRequst = {
          moduleSpecifier,
          resolveFrom: result.pkgFilePath != null ? result.pkgFilePath : result.searchPath
        };
        let id = (0, _RequestTracker.generateRequestId)('dep_version_request', depVersionRequst);
        let shouldSetupInvalidations = graph.invalidNodeIds.has(id) || !graph.hasNode(id);
        let subrequestNode = (0, _nullthrows.default)(graph.addRequest({
          id,
          type: 'dep_version_request',
          request: depVersionRequst,
          result: version
        }));
        (0, _assert.default)(subrequestNode.type === 'request');

        if (shouldSetupInvalidations) {
          if (this.options.lockFile != null) {
            graph.invalidateOnFileUpdate(subrequestNode.id, this.options.lockFile);
          }
        }

        subrequestNodes.push(subrequestNode);
      }
    }

    api.replaceSubrequests(subrequestNodes); // TODO: add includedFiles even if it failed so we can try a rebuild if those files change
  }

}

exports.default = AssetRequestRunner;