"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _utils = require("@parcel/utils");

var _BundleGraph = _interopRequireDefault(require("./BundleGraph"));

var _BundleGraph2 = _interopRequireDefault(require("../BundleGraph"));

var _Bundle = require("./Bundle");

var _Graph = require("../Graph");

var _Asset = require("./Asset");

var _utils2 = require("../utils");

var _Dependency = _interopRequireWildcard(require("./Dependency"));

var _Environment = require("./Environment");

var _Target = require("./Target");

var _constants = require("../constants");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError("attempted to get private field on non-instance"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError("attempted to set private field on non-instance"); } if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } return value; }

class MutableBundleGraph extends _BundleGraph.default {
  // InternalBundleGraph
  // ParcelOptions
  constructor(graph, options) {
    super(graph, (bundle, bundleGraph, options) => new _Bundle.Bundle(bundle, bundleGraph, options), options);

    _graph.set(this, {
      writable: true,
      value: void 0
    });

    _options.set(this, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldSet(this, _graph, graph);

    _classPrivateFieldSet(this, _options, options);
  }

  addAssetGraphToBundle(asset, bundle) {
    _classPrivateFieldGet(this, _graph).addAssetGraphToBundle((0, _Asset.assetToAssetValue)(asset), (0, _Bundle.bundleToInternalBundle)(bundle));
  }

  createBundleGroup(dependency, target) {
    let dependencyNode = _classPrivateFieldGet(this, _graph)._graph.getNode(dependency.id);

    if (!dependencyNode) {
      throw new Error('Dependency not found');
    }

    let resolved = _classPrivateFieldGet(this, _graph).getDependencyResolution((0, _Dependency.dependencyToInternalDependency)(dependency));

    if (!resolved) {
      throw new Error('Dependency did not resolve to an asset ' + dependency.id);
    }

    let bundleGroup = {
      target,
      entryAssetId: resolved.id,
      bundleIds: []
    };
    let bundleGroupNode = {
      id: (0, _utils2.getBundleGroupId)(bundleGroup),
      type: 'bundle_group',
      value: bundleGroup
    };

    _classPrivateFieldGet(this, _graph)._graph.addNode(bundleGroupNode);

    let assetNodes = _classPrivateFieldGet(this, _graph)._graph.getNodesConnectedFrom(dependencyNode);

    _classPrivateFieldGet(this, _graph)._graph.addEdge(dependencyNode.id, bundleGroupNode.id);

    _classPrivateFieldGet(this, _graph)._graph.replaceNodesConnectedTo(bundleGroupNode, assetNodes);

    _classPrivateFieldGet(this, _graph)._graph.addEdge(dependencyNode.id, resolved.id, 'references');

    _classPrivateFieldGet(this, _graph)._graph.removeEdge(dependencyNode.id, resolved.id);

    if (dependency.isEntry) {
      _classPrivateFieldGet(this, _graph)._graph.addEdge((0, _nullthrows.default)(_classPrivateFieldGet(this, _graph)._graph.getRootNode()).id, bundleGroupNode.id, 'bundle');
    } else {
      let inboundBundleNodes = _classPrivateFieldGet(this, _graph)._graph.getNodesConnectedTo(dependencyNode, 'contains');

      for (let inboundBundleNode of inboundBundleNodes) {
        (0, _assert.default)(inboundBundleNode.type === 'bundle');

        _classPrivateFieldGet(this, _graph)._graph.addEdge(inboundBundleNode.id, bundleGroupNode.id, 'bundle');
      }
    }

    return bundleGroup;
  }

  removeBundleGroup(bundleGroup) {
    for (let bundle of this.getBundlesInBundleGroup(bundleGroup)) {
      if (this.getBundleGroupsContainingBundle(bundle).length === 1) {
        _classPrivateFieldGet(this, _graph)._graph.removeById(bundle.id);
      }
    }

    _classPrivateFieldGet(this, _graph)._graph.removeById((0, _utils2.getBundleGroupId)(bundleGroup));
  }

  internalizeAsyncDependency(bundle, dependency) {
    _classPrivateFieldGet(this, _graph).internalizeAsyncDependency((0, _Bundle.bundleToInternalBundle)(bundle), (0, _Dependency.dependencyToInternalDependency)(dependency));
  }

  createBundle(opts) {
    var _opts$uniqueKey, _opts$type, _opts$isSplittable;

    let entryAsset = opts.entryAsset ? (0, _Asset.assetToAssetValue)(opts.entryAsset) : null;
    let target = (0, _Target.targetToInternalTarget)(opts.target);
    let bundleId = (0, _utils.md5FromString)('bundle:' + ((_opts$uniqueKey = opts.uniqueKey) !== null && _opts$uniqueKey !== void 0 ? _opts$uniqueKey : (0, _nullthrows.default)(entryAsset === null || entryAsset === void 0 ? void 0 : entryAsset.id)) + target.distDir);
    let bundleNode = {
      type: 'bundle',
      id: bundleId,
      value: {
        id: bundleId,
        hashReference: _classPrivateFieldGet(this, _options).contentHash ? _constants.HASH_REF_PREFIX + bundleId : bundleId.slice(0, 8),
        type: (_opts$type = opts.type) !== null && _opts$type !== void 0 ? _opts$type : (0, _nullthrows.default)(entryAsset).type,
        env: opts.env ? (0, _Environment.environmentToInternalEnvironment)(opts.env) : (0, _nullthrows.default)(entryAsset).env,
        entryAssetIds: entryAsset ? [entryAsset.id] : [],
        pipeline: entryAsset ? entryAsset.pipeline : null,
        filePath: null,
        isEntry: opts.isEntry,
        isInline: opts.isInline,
        isSplittable: (_opts$isSplittable = opts.isSplittable) !== null && _opts$isSplittable !== void 0 ? _opts$isSplittable : entryAsset === null || entryAsset === void 0 ? void 0 : entryAsset.isSplittable,
        target,
        name: null,
        displayName: null,
        stats: {
          size: 0,
          time: 0
        }
      }
    };

    _classPrivateFieldGet(this, _graph)._graph.addNode(bundleNode);

    if (opts.entryAsset) {
      _classPrivateFieldGet(this, _graph)._graph.addEdge(bundleNode.id, opts.entryAsset.id);
    }

    return new _Bundle.Bundle(bundleNode.value, _classPrivateFieldGet(this, _graph), _classPrivateFieldGet(this, _options));
  }

  addBundleToBundleGroup(bundle, bundleGroup) {
    bundleGroup.bundleIds.push(bundle.id);
    let bundleGroupId = (0, _utils2.getBundleGroupId)(bundleGroup);

    _classPrivateFieldGet(this, _graph)._graph.addEdge(bundleGroupId, bundle.id);

    _classPrivateFieldGet(this, _graph)._graph.addEdge(bundleGroupId, bundle.id, 'bundle');

    for (let entryAsset of bundle.getEntryAssets()) {
      if (_classPrivateFieldGet(this, _graph)._graph.hasEdge(bundleGroupId, entryAsset.id)) {
        _classPrivateFieldGet(this, _graph)._graph.removeEdge(bundleGroupId, entryAsset.id);
      }
    }
  }

  createAssetReference(dependency, asset) {
    return _classPrivateFieldGet(this, _graph).createAssetReference((0, _Dependency.dependencyToInternalDependency)(dependency), (0, _Asset.assetToAssetValue)(asset));
  }

  createBundleReference(from, to) {
    return _classPrivateFieldGet(this, _graph).createBundleReference((0, _Bundle.bundleToInternalBundle)(from), (0, _Bundle.bundleToInternalBundle)(to));
  }

  getDependencyAssets(dependency) {
    return _classPrivateFieldGet(this, _graph).getDependencyAssets((0, _Dependency.dependencyToInternalDependency)(dependency)).map(asset => (0, _Asset.assetFromValue)(asset, _classPrivateFieldGet(this, _options)));
  }

  traverse(visit) {
    return _classPrivateFieldGet(this, _graph)._graph.filteredTraverse(node => {
      if (node.type === 'asset') {
        return {
          type: 'asset',
          value: (0, _Asset.assetFromValue)(node.value, _classPrivateFieldGet(this, _options))
        };
      } else if (node.type === 'dependency') {
        return {
          type: 'dependency',
          value: new _Dependency.default(node.value)
        };
      }
    }, visit, undefined, // start with root
    // $FlowFixMe
    _Graph.ALL_EDGE_TYPES);
  }

  getBundleGroupsContainingBundle(bundle) {
    return _classPrivateFieldGet(this, _graph).getBundleGroupsContainingBundle((0, _Bundle.bundleToInternalBundle)(bundle));
  }

  getParentBundlesOfBundleGroup(bundleGroup) {
    return _classPrivateFieldGet(this, _graph).getParentBundlesOfBundleGroup(bundleGroup).map(bundle => new _Bundle.Bundle(bundle, _classPrivateFieldGet(this, _graph), _classPrivateFieldGet(this, _options)));
  }

  getTotalSize(asset) {
    return _classPrivateFieldGet(this, _graph).getTotalSize((0, _Asset.assetToAssetValue)(asset));
  }

  isAssetReachableFromBundle(asset, bundle) {
    return _classPrivateFieldGet(this, _graph).isAssetReachableFromBundle((0, _Asset.assetToAssetValue)(asset), (0, _Bundle.bundleToInternalBundle)(bundle));
  }

  removeAssetGraphFromBundle(asset, bundle) {
    _classPrivateFieldGet(this, _graph).removeAssetGraphFromBundle((0, _Asset.assetToAssetValue)(asset), (0, _Bundle.bundleToInternalBundle)(bundle));
  }

  traverseContents(visit) {
    return _classPrivateFieldGet(this, _graph).traverseContents((0, _Graph.mapVisitor)(node => node.type === 'asset' ? {
      type: 'asset',
      value: (0, _Asset.assetFromValue)(node.value, _classPrivateFieldGet(this, _options))
    } : {
      type: 'dependency',
      value: new _Dependency.default(node.value)
    }, visit));
  }

}

exports.default = MutableBundleGraph;

var _graph = new WeakMap();

var _options = new WeakMap();