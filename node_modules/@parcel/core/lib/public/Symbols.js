"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MutableAssetSymbols = exports.MutableDependencySymbols = exports.Symbols = void 0;

var _nullthrows = _interopRequireDefault(require("nullthrows"));

let _Symbol$iterator, _Symbol$iterator2;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError("attempted to get private field on non-instance"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError("attempted to set private field on non-instance"); } if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } return value; }

const EMPTY_ITERATOR = {
  next() {
    return {
      done: true
    };
  }

};
let valueToSymbols = new WeakMap();
_Symbol$iterator = Symbol.iterator;

class Symbols {
  /*::
  @@iterator(): Iterator<[Symbol, {|local: Symbol, loc: ?SourceLocation|}]> { return ({}: any); }
  */
  // Asset
  constructor(asset) {
    _value.set(this, {
      writable: true,
      value: void 0
    });

    let existing = valueToSymbols.get(asset);

    if (existing != null) {
      return existing;
    }

    _classPrivateFieldSet(this, _value, asset);

    valueToSymbols.set(asset, this);
  }

  get(exportSymbol) {
    var _classPrivateFieldGet2;

    return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _value).symbols) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.get(exportSymbol);
  }

  hasExportSymbol(exportSymbol) {
    var _classPrivateFieldGet3;

    return Boolean((_classPrivateFieldGet3 = _classPrivateFieldGet(this, _value).symbols) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.has(exportSymbol));
  }

  hasLocalSymbol(local) {
    if (_classPrivateFieldGet(this, _value).symbols) {
      for (let s of _classPrivateFieldGet(this, _value).symbols.values()) {
        if (local === s.local) return true;
      }
    }

    return false;
  } // $FlowFixMe


  [_Symbol$iterator]() {
    return _classPrivateFieldGet(this, _value).symbols ? _classPrivateFieldGet(this, _value).symbols[Symbol.iterator]() : EMPTY_ITERATOR;
  }

  get isCleared() {
    return _classPrivateFieldGet(this, _value).symbols == null;
  }

}

exports.Symbols = Symbols;

var _value = new WeakMap();

let valueToMutableSymbols = new WeakMap();
_Symbol$iterator2 = Symbol.iterator;

class MutableSymbols {
  /*::
  @@iterator(): Iterator<[Symbol, {|local: Symbol, loc: ?SourceLocation|}]> { return ({}: any); }
  */
  // Asset
  constructor(asset) {
    _value2.set(this, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldSet(this, _value2, asset);
  }

  set(exportSymbol, local, loc) {
    (0, _nullthrows.default)(_classPrivateFieldGet(this, _value2).symbols, 'Cannot set symbol on cleared Symbols').set(exportSymbol, {
      local,
      loc
    });
  }

  get(exportSymbol) {
    var _classPrivateFieldGet4;

    return (_classPrivateFieldGet4 = _classPrivateFieldGet(this, _value2).symbols) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.get(exportSymbol);
  }

  hasExportSymbol(exportSymbol) {
    var _classPrivateFieldGet5;

    return Boolean((_classPrivateFieldGet5 = _classPrivateFieldGet(this, _value2).symbols) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.has(exportSymbol));
  }

  hasLocalSymbol(local) {
    if (_classPrivateFieldGet(this, _value2).symbols) {
      for (let s of _classPrivateFieldGet(this, _value2).symbols.values()) {
        if (local === s.local) return true;
      }
    }

    return false;
  } // $FlowFixMe


  [_Symbol$iterator2]() {
    return _classPrivateFieldGet(this, _value2).symbols ? _classPrivateFieldGet(this, _value2).symbols[Symbol.iterator]() : EMPTY_ITERATOR;
  }

  get isCleared() {
    return _classPrivateFieldGet(this, _value2).symbols == null;
  }

}

var _value2 = new WeakMap();

class MutableDependencySymbols extends MutableSymbols {
  // Dependency
  constructor(dependency) {
    let existing = valueToMutableSymbols.get(dependency);

    if (existing != null) {
      return existing;
    }

    super(dependency);

    _dependency.set(this, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldSet(this, _dependency, dependency);
  }

  clear() {
    _classPrivateFieldGet(this, _dependency).symbols.clear();
  }

}

exports.MutableDependencySymbols = MutableDependencySymbols;

var _dependency = new WeakMap();

class MutableAssetSymbols extends MutableSymbols {
  // Asset
  constructor(asset) {
    super(asset);

    _asset.set(this, {
      writable: true,
      value: void 0
    });

    let existing = valueToMutableSymbols.get(asset);

    if (existing != null) {
      return existing;
    }

    _classPrivateFieldSet(this, _asset, asset);
  }

  clear() {
    _classPrivateFieldGet(this, _asset).symbols = null;
  }

}

exports.MutableAssetSymbols = MutableAssetSymbols;

var _asset = new WeakMap();