"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("v8"));

var _stream = require("stream");

var _sourceMap = _interopRequireDefault(require("@parcel/source-map"));

var _utils = require("@parcel/utils");

var _Dependency = require("./Dependency");

var _Environment = require("./Environment");

var _constants = require("./constants");

var _assetUtils = require("./assetUtils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class UncommittedAsset {
  constructor({
    value,
    options,
    content,
    mapBuffer,
    ast,
    isASTDirty,
    idBase
  }) {
    _defineProperty(this, "value", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "content", void 0);

    _defineProperty(this, "mapBuffer", void 0);

    _defineProperty(this, "map", void 0);

    _defineProperty(this, "ast", void 0);

    _defineProperty(this, "isASTDirty", void 0);

    _defineProperty(this, "idBase", void 0);

    this.value = value;
    this.options = options;
    this.content = content;
    this.mapBuffer = mapBuffer;
    this.ast = ast;
    this.isASTDirty = isASTDirty || false;
    this.idBase = idBase;
  }
  /*
   * Prepares the asset for being serialized to the cache by commiting its
   * content and map of the asset to the cache.
   */


  async commit(pipelineKey) {
    // If there is a dirty AST, clear out any old content and map as these
    // must be regenerated later and shouldn't be committed.
    if (this.ast != null && this.isASTDirty) {
      this.content = null;
      this.mapBuffer = null;
    }

    let size = 0;
    let contentKey = this.content == null ? null : this.getCacheKey('content' + pipelineKey);
    let mapKey = this.mapBuffer == null ? null : this.getCacheKey('map' + pipelineKey);
    let astKey = this.ast == null ? null : this.getCacheKey('ast' + pipelineKey); // Since we can only read from the stream once, compute the content length
    // and hash while it's being written to the cache.

    await Promise.all([contentKey != null && this.options.cache.setStream(contentKey, this.getStream().pipe(new _utils.TapStream(buf => {
      size += buf.length;
    }))), this.mapBuffer != null && mapKey != null && this.options.cache.setBlob(mapKey, this.mapBuffer), astKey != null && this.options.cache.setBlob(astKey, // $FlowFixMe
    _v.default.serialize(this.ast))]);
    this.value.contentKey = contentKey;
    this.value.mapKey = mapKey;
    this.value.astKey = astKey;
    this.value.outputHash = (0, _utils.md5FromString)([this.value.hash, pipelineKey].join(':'));

    if (this.content != null) {
      this.value.stats.size = size;
    }

    this.value.committed = true;
  }

  async getCode() {
    if (this.ast != null && this.isASTDirty) {
      throw new Error('Cannot call getCode() on an asset with a dirty AST. For transformers, implement canReuseAST() and check asset.isASTDirty.');
    }

    let content = await this.content;

    if (typeof content === 'string' || content instanceof Buffer) {
      return content.toString();
    } else if (content != null) {
      this.content = (0, _utils.bufferStream)(content);
      return (await this.content).toString();
    }

    return '';
  }

  async getBuffer() {
    let content = await this.content;

    if (content == null) {
      return Buffer.alloc(0);
    } else if (typeof content === 'string' || content instanceof Buffer) {
      return Buffer.from(content);
    }

    this.content = (0, _utils.bufferStream)(content);
    return this.content;
  }

  getStream() {
    var _this$content;

    if (this.content instanceof _stream.Readable) {
      // Remove content if it's a stream, as it should not be reused.
      let content = this.content;
      this.content = null;
      return content;
    }

    if (this.content instanceof Promise) {
      return (0, _utils.streamFromPromise)(this.content);
    }

    return (0, _utils.blobToStream)((_this$content = this.content) !== null && _this$content !== void 0 ? _this$content : Buffer.alloc(0));
  }

  setCode(code) {
    this.content = code;
    this.clearAST();
  }

  setBuffer(buffer) {
    this.content = buffer;
    this.clearAST();
  }

  setStream(stream) {
    this.content = stream;
    this.clearAST();
  }

  getMapBuffer() {
    return Promise.resolve(this.mapBuffer);
  }

  async getMap() {
    if (this.map == null) {
      var _this$mapBuffer;

      let mapBuffer = (_this$mapBuffer = this.mapBuffer) !== null && _this$mapBuffer !== void 0 ? _this$mapBuffer : await this.getMapBuffer();

      if (mapBuffer) {
        // Get sourcemap from flatbuffer
        let map = new _sourceMap.default();
        map.addBufferMappings(mapBuffer);
        this.map = map;
      }
    }

    return this.map;
  }

  setMap(map) {
    this.mapBuffer = map === null || map === void 0 ? void 0 : map.toBuffer();
  }

  getAST() {
    return Promise.resolve(this.ast);
  }

  setAST(ast) {
    this.ast = ast;
    this.isASTDirty = true;
    this.value.astGenerator = {
      type: ast.type,
      version: ast.version
    };
  }

  clearAST() {
    this.ast = null;
    this.isASTDirty = false;
    this.value.astGenerator = null;
  }

  getCacheKey(key) {
    return (0, _utils.md5FromString)(_constants.PARCEL_VERSION + key + this.value.id + (this.value.hash || ''));
  }

  addDependency(opts) {
    // eslint-disable-next-line no-unused-vars
    let {
      env,
      target,
      symbols,
      ...rest
    } = opts;
    let dep = (0, _Dependency.createDependency)({ ...rest,
      // $FlowFixMe "convert" the $ReadOnlyMaps to the interal mutable one
      symbols,
      env: (0, _Environment.mergeEnvironments)(this.value.env, env),
      sourceAssetId: this.value.id,
      sourcePath: this.value.filePath
    });
    let existing = this.value.dependencies.get(dep.id);

    if (existing) {
      (0, _Dependency.mergeDependencies)(existing, dep);
    } else {
      this.value.dependencies.set(dep.id, dep);
    }

    return dep.id;
  }

  addIncludedFile(file) {
    this.value.includedFiles.set(file.filePath, file);
  }

  getIncludedFiles() {
    return Array.from(this.value.includedFiles.values());
  }

  getDependencies() {
    return Array.from(this.value.dependencies.values());
  }

  createChildAsset(result, plugin, configPath) {
    var _result$content, _result$isIsolated, _result$isInline, _result$isSplittable, _result$isSource, _result$pipeline, _result$sideEffects;

    let content = (_result$content = result.content) !== null && _result$content !== void 0 ? _result$content : null;
    let asset = new UncommittedAsset({
      value: (0, _assetUtils.createAsset)({
        idBase: this.idBase,
        hash: this.value.hash,
        filePath: this.value.filePath,
        type: result.type,
        isIsolated: (_result$isIsolated = result.isIsolated) !== null && _result$isIsolated !== void 0 ? _result$isIsolated : this.value.isIsolated,
        isInline: (_result$isInline = result.isInline) !== null && _result$isInline !== void 0 ? _result$isInline : this.value.isInline,
        isSplittable: (_result$isSplittable = result.isSplittable) !== null && _result$isSplittable !== void 0 ? _result$isSplittable : this.value.isSplittable,
        isSource: (_result$isSource = result.isSource) !== null && _result$isSource !== void 0 ? _result$isSource : this.value.isSource,
        env: (0, _Environment.mergeEnvironments)(this.value.env, result.env),
        dependencies: this.value.type === result.type ? new Map(this.value.dependencies) : new Map(),
        includedFiles: new Map(this.value.includedFiles),
        meta: { ...this.value.meta,
          ...result.meta
        },
        pipeline: (_result$pipeline = result.pipeline) !== null && _result$pipeline !== void 0 ? _result$pipeline : this.value.type === result.type ? this.value.pipeline : null,
        stats: {
          time: 0,
          size: this.value.stats.size
        },
        symbols: !result.symbols ? // TODO clone?
        this.value.symbols : new Map([...(this.value.symbols || []), ...(result.symbols || [])]),
        sideEffects: (_result$sideEffects = result.sideEffects) !== null && _result$sideEffects !== void 0 ? _result$sideEffects : this.value.sideEffects,
        uniqueKey: result.uniqueKey,
        astGenerator: result.ast ? {
          type: result.ast.type,
          version: result.ast.version
        } : null,
        plugin,
        configPath
      }),
      options: this.options,
      content,
      ast: result.ast,
      isASTDirty: result.ast === this.ast ? this.isASTDirty : true,
      mapBuffer: result.map ? result.map.toBuffer() : null,
      idBase: this.idBase
    });
    let dependencies = result.dependencies;

    if (dependencies) {
      for (let dep of dependencies) {
        asset.addDependency(dep);
      }
    }

    let includedFiles = result.includedFiles;

    if (includedFiles) {
      for (let file of includedFiles) {
        asset.addIncludedFile(file);
      }
    }

    return asset;
  }

  async getConfig(filePaths, options) {
    let conf = await (0, _assetUtils.getConfig)(this, filePaths, options);

    if (conf == null) {
      return null;
    }

    for (let file of conf.files) {
      this.addIncludedFile(file);
    }

    return conf.config;
  }

  getPackage() {
    return this.getConfig(['package.json']);
  }

}

exports.default = UncommittedAsset;