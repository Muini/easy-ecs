"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = summarizeRequest;

var _utils = require("@parcel/utils");

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NODE_MODULES = `${_path.default.sep}node_modules${_path.default.sep}`;
const BUFFER_LIMIT = 5000000; // 5mb

async function summarizeRequest(fs, req) {
  let [{
    content,
    hash,
    size
  }, isSource] = await Promise.all([summarizeDiskRequest(fs, req), isFilePathSource(fs, req.filePath)]);
  return {
    content,
    hash,
    size,
    isSource
  };
}

async function isFilePathSource(fs, filePath) {
  return !filePath.includes(NODE_MODULES) || (await fs.realpath(filePath)) !== filePath;
}

function summarizeDiskRequest(fs, req) {
  return new Promise((resolve, reject) => {
    let code = req.code;
    let content;
    let hash;
    let size;

    if (code == null) {
      // As an optimization for the common case of source code, while we read in
      // data to compute its md5 and size, buffer its contents in memory.
      // This avoids reading the data now, and then again during transformation.
      // If it exceeds BUFFER_LIMIT, throw it out and replace it with a stream to
      // lazily read it at a later point.
      content = Buffer.from([]);
      size = 0;
      let stream = fs.createReadStream(req.filePath);
      stream.on('error', reject);
      (0, _utils.md5FromReadableStream)(stream.pipe(new _utils.TapStream(buf => {
        size += buf.length;

        if (content instanceof Buffer) {
          if (size > BUFFER_LIMIT) {
            // if buffering this content would put this over BUFFER_LIMIT, replace
            // it with a stream
            content = fs.createReadStream(req.filePath);
          } else {
            content = Buffer.concat([content, buf]);
          }
        }
      }))).then(hash => resolve({
        content,
        hash,
        size
      }), reject);
    } else {
      content = code;
      hash = (0, _utils.md5FromString)(code);
      size = Buffer.from(code).length;
      resolve({
        content,
        hash,
        size
      });
    }
  });
}