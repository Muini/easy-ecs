"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = applyRuntimes;

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _AssetGraph = _interopRequireWildcard(require("./AssetGraph"));

var _BundleGraph = _interopRequireDefault(require("./public/BundleGraph"));

var _BundleGraph2 = require("./BundleGraph");

var _Bundle = require("./public/Bundle");

var _utils = require("@parcel/utils");

var _logger = require("@parcel/logger");

var _diagnostic = _interopRequireWildcard(require("@parcel/diagnostic"));

var _Dependency = require("./public/Dependency");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function applyRuntimes({
  bundleGraph,
  config,
  options,
  pluginOptions,
  runtimesBuilder
}) {
  let connections = [];

  for (let bundle of bundleGraph.getBundles()) {
    let runtimes = await config.getRuntimes(bundle.env.context);

    for (let runtime of runtimes) {
      try {
        let applied = await runtime.plugin.apply({
          bundle: new _Bundle.NamedBundle(bundle, bundleGraph, options),
          bundleGraph: new _BundleGraph.default(bundleGraph, (bundle, bundleGraph, options) => new _Bundle.NamedBundle(bundle, bundleGraph, options), options),
          options: pluginOptions,
          logger: new _logger.PluginLogger({
            origin: runtime.name
          })
        });

        if (applied) {
          let runtimeAssets = Array.isArray(applied) ? applied : [applied];

          for (let {
            code,
            dependency,
            filePath,
            isEntry
          } of runtimeAssets) {
            let assetRequest = {
              code,
              filePath,
              env: bundle.env,
              // Runtime assets should be considered source, as they should be
              // e.g. compiled to run in the target environment
              isSource: true
            };
            connections.push({
              bundle,
              assetRequest,
              dependency: dependency,
              isEntry
            });
          }
        }
      } catch (e) {
        throw new _diagnostic.default({
          diagnostic: (0, _diagnostic.errorToDiagnostic)(e, runtime.name)
        });
      }
    }
  }

  let runtimesAssetGraph = await reconcileNewRuntimes(runtimesBuilder, connections);
  let runtimesGraph = (0, _BundleGraph2.removeAssetGroups)(runtimesAssetGraph); // merge the transformed asset into the bundle's graph, and connect
  // the node to it.

  bundleGraph._graph.merge(runtimesGraph);

  for (let {
    bundle,
    assetRequest,
    dependency,
    isEntry
  } of connections) {
    let assetGroupNode = (0, _AssetGraph.nodeFromAssetGroup)(assetRequest);
    let assetGroupAssets = runtimesAssetGraph.getNodesConnectedFrom(assetGroupNode);
    (0, _assert.default)(assetGroupAssets.length === 1);
    let runtimeNode = assetGroupAssets[0];
    (0, _assert.default)(runtimeNode.type === 'asset');
    let resolution = dependency && bundleGraph.getDependencyResolution((0, _Dependency.dependencyToInternalDependency)(dependency), bundle);
    let duplicatedAssetIds = new Set();
    runtimesGraph.traverse((node, _, actions) => {
      if (node.type !== 'dependency') {
        return;
      }

      let assets = runtimesGraph.getNodesConnectedFrom(node).map(assetNode => {
        (0, _assert.default)(assetNode.type === 'asset');
        return assetNode.value;
      });

      for (let asset of assets) {
        if (bundleGraph.isAssetReachableFromBundle(asset, bundle) || (resolution === null || resolution === void 0 ? void 0 : resolution.id) === asset.id) {
          duplicatedAssetIds.add(asset.id);
          actions.skipChildren();
        }
      }
    }, runtimeNode);
    runtimesGraph.traverse((node, _, actions) => {
      if (node.type === 'asset' || node.type === 'dependency') {
        if (duplicatedAssetIds.has(node.id)) {
          actions.skipChildren();
          return;
        }

        bundleGraph._graph.addEdge(bundle.id, node.id, 'contains');
      }
    }, runtimeNode);

    if (isEntry) {
      bundleGraph._graph.addEdge((0, _nullthrows.default)(bundleGraph._graph.getNode(bundle.id)).id, runtimeNode.id);

      bundle.entryAssetIds.unshift(runtimeNode.id);
    }

    if (dependency == null) {
      // Verify this asset won't become an island
      (0, _assert.default)(bundleGraph._graph.getNodesConnectedTo(runtimeNode).length > 0, 'Runtime must have an inbound dependency or be an entry');
    } else {
      bundleGraph._graph.addEdge(dependency.id, runtimeNode.id);
    }
  }
}

async function reconcileNewRuntimes(runtimesBuilder, connections) {
  let {
    assetGraph
  } = runtimesBuilder;
  let assetRequestNodesById = new Map(connections.map(t => t.assetRequest).map(request => {
    let node = (0, _AssetGraph.nodeFromAssetGroup)(request);
    return [node.id, node];
  }));
  let newRequestIds = new Set(assetRequestNodesById.keys());
  let oldRequestIds = new Set(assetGraph.getEntryAssetGroupNodes().map(node => node.id));
  let toAdd = (0, _utils.setDifference)(newRequestIds, oldRequestIds);
  let toRemove = (0, _utils.setDifference)(oldRequestIds, newRequestIds);
  assetGraph.replaceNodesConnectedTo((0, _nullthrows.default)(assetGraph.getRootNode()), [...toAdd].map(requestId => (0, _nullthrows.default)(assetRequestNodesById.get(requestId))), node => toRemove.has(node.id)); // rebuild the graph

  return (await runtimesBuilder.build()).assetGraph;
}