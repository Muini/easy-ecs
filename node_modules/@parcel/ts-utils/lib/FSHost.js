"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FSHost = void 0;

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class FSHost {
  constructor(fs, ts) {
    _defineProperty(this, "fs", void 0);

    _defineProperty(this, "ts", void 0);

    this.fs = fs;
    this.ts = ts;
  }

  getCurrentDirectory() {
    return this.fs.cwd();
  }

  fileExists(filePath) {
    try {
      return this.fs.statSync(filePath).isFile();
    } catch (err) {
      return false;
    }
  }

  readFile(filePath) {
    try {
      return this.fs.readFileSync(filePath, 'utf8');
    } catch (err) {
      if (err.code === 'ENOENT') {
        return undefined;
      }

      throw err;
    }
  }

  directoryExists(filePath) {
    try {
      return this.fs.statSync(filePath).isDirectory();
    } catch (err) {
      return false;
    }
  }

  realpath(filePath) {
    try {
      return this.fs.realpathSync(filePath);
    } catch (err) {
      return filePath;
    }
  }

  getAccessibleFileSystemEntries(dirPath) {
    try {
      let entries = this.fs.readdirSync(dirPath || '.').sort();
      let files = [];
      let directories = [];

      for (let entry of entries) {
        let filePath = _path.default.join(dirPath, entry);

        let stat;

        try {
          stat = this.fs.statSync(filePath);
        } catch (e) {
          continue;
        }

        if (stat.isFile()) {
          files.push(entry);
        } else if (stat.isDirectory()) {
          directories.push(entry);
        }
      }

      return {
        files,
        directories
      };
    } catch (err) {
      return {
        files: [],
        directories: []
      };
    }
  }

  readDirectory(root, extensions, excludes, includes, depth) {
    // $FlowFixMe
    return this.ts.matchFiles(root, extensions, excludes, includes, this.ts.sys.useCaseSensitiveFileNames, this.getCurrentDirectory(), depth, this.getAccessibleFileSystemEntries.bind(this), this.realpath.bind(this));
  }

}

exports.FSHost = FSHost;