"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._addToInstallQueue = _addToInstallQueue;
exports.installPackage = installPackage;

var _assert = _interopRequireDefault(require("assert"));

var _path = _interopRequireDefault(require("path"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _semver = _interopRequireDefault(require("semver"));

var _diagnostic = _interopRequireWildcard(require("@parcel/diagnostic"));

var _logger = _interopRequireDefault(require("@parcel/logger"));

var _utils = require("@parcel/utils");

var _workers = _interopRequireDefault(require("@parcel/workers"));

var _Npm = require("./Npm");

var _Yarn = require("./Yarn");

var _utils2 = require("./utils");

var _validateModuleSpecifier = _interopRequireDefault(require("./validateModuleSpecifier"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function install(fs, modules, from, options = {}) {
  let {
    installPeers = true,
    saveDev = true,
    packageInstaller
  } = options;
  let moduleNames = modules.map(m => m.name).join(', ');

  _logger.default.progress(`Installing ${moduleNames}...`);

  let fromPkgPath = await (0, _utils.resolveConfig)(fs, from, ['package.json']);
  let cwd = fromPkgPath ? _path.default.dirname(fromPkgPath) : fs.cwd();

  if (!packageInstaller) {
    packageInstaller = await determinePackageInstaller(fs, from);
  }

  try {
    await packageInstaller.install({
      modules,
      saveDev,
      cwd,
      packagePath: fromPkgPath,
      fs
    });
  } catch (err) {
    throw new Error(`Failed to install ${moduleNames}.`);
  }

  if (installPeers) {
    await Promise.all(modules.map(m => installPeerDependencies(fs, m, from, options)));
  }
}

async function installPeerDependencies(fs, module, from, options) {
  let basedir = _path.default.dirname(from);

  const {
    resolved
  } = await (0, _utils.resolve)(fs, module.name, {
    basedir,
    range: module.range
  });
  const modulePkg = (0, _nullthrows.default)((await (0, _utils.loadConfig)(fs, resolved, ['package.json']))).config;
  const peers = modulePkg.peerDependencies || {};
  let modules = [];

  for (let [name, range] of Object.entries(peers)) {
    (0, _assert.default)(typeof range === 'string');
    let conflicts = await (0, _utils2.getConflictingLocalDependencies)(fs, name, from);

    if (conflicts) {
      let {
        pkg
      } = await (0, _utils.resolve)(fs, name, {
        basedir
      });
      (0, _assert.default)(pkg);

      if (!_semver.default.satisfies(pkg.version, range)) {
        throw new _diagnostic.default({
          diagnostic: {
            message: `Could not install the peer dependency "${name}" for "${module.name}", installed version ${pkg.version} is incompatible with ${range}`,
            filePath: conflicts.filePath,
            origin: '@parcel/package-manager',
            language: 'json',
            codeFrame: {
              code: conflicts.json,
              codeHighlights: (0, _diagnostic.generateJSONCodeHighlights)(conflicts.json, conflicts.fields.map(field => ({
                key: `/${field}/${(0, _diagnostic.encodeJSONKeyComponent)(name)}`,
                type: 'key',
                message: 'Found this conflicting local requirement.'
              })))
            }
          }
        });
      }

      continue;
    }

    modules.push({
      name,
      range
    });
  }

  if (modules.length) {
    await install(fs, modules, from, Object.assign({}, options, {
      installPeers: false
    }));
  }
}

async function determinePackageInstaller(fs, filepath) {
  let configFile = await (0, _utils.resolveConfig)(fs, filepath, ['yarn.lock', 'package-lock.json']);
  let hasYarn = await _Yarn.Yarn.exists(); // If Yarn isn't available, or there is a package-lock.json file, use npm.

  let configName = configFile && _path.default.basename(configFile);

  if (!hasYarn || configName === 'package-lock.json') {
    return new _Npm.Npm();
  }

  return new _Yarn.Yarn();
}

let queue = new _utils.PromiseQueue({
  maxConcurrent: 1
});
let modulesInstalling = new Set(); // Exported so that it may be invoked from the worker api below.
// Do not call this directly! This can result in concurrent package installations
// across multiple instances of the package manager.

function _addToInstallQueue(fs, modules, filePath, options) {
  modules = modules.map(request => ({
    name: (0, _validateModuleSpecifier.default)(request.name),
    range: request.range
  })); // Wrap PromiseQueue and track modules that are currently installing.
  // If a request comes in for a module that is currently installing, don't bother
  // enqueuing it.

  let modulesToInstall = modules.filter(m => !modulesInstalling.has(getModuleRequestKey(m)));

  if (modulesToInstall.length) {
    for (let m of modulesToInstall) {
      modulesInstalling.add(getModuleRequestKey(m));
    }

    queue.add(() => install(fs, modulesToInstall, filePath, options).then(() => {
      for (let m of modulesToInstall) {
        modulesInstalling.delete(getModuleRequestKey(m));
      }
    })).then(() => {}, () => {});
  }

  return queue.run();
}

function installPackage(fs, modules, filePath, options) {
  if (_workers.default.isWorker()) {
    let workerApi = _workers.default.getWorkerApi();

    return workerApi.callMaster({
      location: __filename,
      args: [fs, modules, filePath, options],
      method: '_addToInstallQueue'
    });
  }

  return _addToInstallQueue(fs, modules, filePath, options);
}

function getModuleRequestKey(moduleRequest) {
  return [moduleRequest.name, moduleRequest.range].join('@');
}