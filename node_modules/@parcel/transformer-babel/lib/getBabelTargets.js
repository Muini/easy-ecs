"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBabelTargets;

var _browserslist = _interopRequireDefault(require("browserslist"));

var _semver = _interopRequireDefault(require("semver"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const BROWSER_CONTEXT = new Set(['browser', 'web-worker', 'service-worker']); // https://github.com/browserslist/browserslist/blob/04d7b3cc6ebeb62baf6d62aeb90f1bfd0c11117c/test/config.test.js#L23

/**
 * Loads target node and browser versions from the following locations:
 *   - package.json engines field
 *   - package.json browserslist field
 *   - browserslist or .browserslistrc files
 *
 * "Targets" is the name @babel/preset-env uses for what Parcel calls engines.
 * This should not be confused with Parcel's own targets.
 * Unlike Parcel's engines, @babel/preset-env expects to work with minimum
 * versions, not semver ranges, of its targets.
 */
async function getBabelTargets(config) {
  let targets = {};
  let compileTarget = BROWSER_CONTEXT.has(config.env.context) ? 'browsers' : config.env.context;
  let pkg = await config.getPackage();
  let packageEngines = pkg === null || pkg === void 0 ? void 0 : pkg.engines;

  if (compileTarget === 'node') {
    let nodeVersion = packageEngines === null || packageEngines === void 0 ? void 0 : packageEngines.node; // Use package.engines.node by default if we are compiling for node.

    if (typeof nodeVersion === 'string') {
      try {
        //$FlowFixMe catch error when minVersion() returned null
        targets.node = _semver.default.minVersion(nodeVersion).version;
      } catch (e) {
        throw new Error("Expected 'node' engine to be a valid Semver Range");
      }
    }
  } else {
    let browsers;

    if (packageEngines && (typeof packageEngines.browsers === 'string' || Array.isArray(packageEngines.browsers))) {
      browsers = packageEngines.browsers;
    } else if (pkg && pkg.browserslist) {
      browsers = pkg.browserslist;
    } else {
      let browserslist = await loadBrowserslist(config);

      if (browserslist) {
        browsers = browserslist;
      }
    } // Parse browser targets


    if (typeof browsers === 'object' && browsers != null && !Array.isArray(browsers)) {
      let env = process.env.NODE_ENV || 'development';
      browsers = browsers[env] || browsers.defaults;
    }

    if (browsers) {
      targets.browsers = (0, _browserslist.default)(browsers).sort();
    }
  } // Dont compile if we couldn't find any targets


  if (Object.keys(targets).length === 0) {
    return null;
  }

  return targets;
}

async function loadBrowserslist(config) {
  let browserslistConfig = await config.getConfig(['browserslist', '.browserslistrc'], {
    parse: false
  });

  if (browserslistConfig) {
    return _browserslist.default.parseConfig(browserslistConfig.contents);
  }
}