"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = babel7;

var _assert = _interopRequireDefault(require("assert"));

var bundledBabelCore = _interopRequireWildcard(require("@babel/core"));

var _utils = require("@parcel/utils");

var _constants = require("./constants");

var _package = _interopRequireDefault(require("../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const transformerVersion = _package.default.version;
(0, _assert.default)(typeof transformerVersion === 'string');

async function babel7(asset, options, babelOptions, additionalPlugins = []) {
  // If this is an internally generated config, use our internal @babel/core,
  // otherwise require a local version from the package we're compiling.
  let babel = babelOptions.internal ? bundledBabelCore : await options.packageManager.require('@babel/core', asset.filePath, {
    range: _constants.BABEL_RANGE,
    autoinstall: options.autoinstall
  });
  let config = { ...babelOptions.config,
    plugins: additionalPlugins.concat(babelOptions.config.plugins),
    code: false,
    ast: true,
    filename: asset.filePath,
    babelrc: false,
    configFile: false,
    parserOpts: { ...babelOptions.config.parserOpts,
      sourceFilename: (0, _utils.relativeUrl)(options.projectRoot, asset.filePath),
      allowReturnOutsideFunction: true,
      strictMode: false,
      sourceType: 'module',
      plugins: ['dynamicImport']
    },
    caller: {
      name: 'parcel',
      version: transformerVersion,
      targets: JSON.stringify(babelOptions.targets),
      outputFormat: asset.env.outputFormat
    }
  };
  let ast = await asset.getAST();
  let res;

  if (ast) {
    res = await babel.transformFromAstAsync(ast.program, asset.isASTDirty() ? undefined : await asset.getCode(), config);
  } else {
    res = await babel.transformAsync((await asset.getCode()), config);
  }

  if (res.ast) {
    asset.setAST({
      type: 'babel',
      version: '7.0.0',
      program: res.ast
    });
  }
}