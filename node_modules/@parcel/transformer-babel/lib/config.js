"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.load = load;
exports.preSerialize = preSerialize;
exports.postDeserialize = postDeserialize;

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _path = _interopRequireDefault(require("path"));

var bundledBabelCore = _interopRequireWildcard(require("@babel/core"));

var _utils = require("@parcel/utils");

var _env = _interopRequireDefault(require("./env"));

var _jsx = _interopRequireDefault(require("./jsx"));

var _flow = _interopRequireDefault(require("./flow"));

var _typescript = _interopRequireDefault(require("./typescript"));

var _utils2 = require("./utils");

var _constants = require("./constants");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TYPESCRIPT_EXTNAME_RE = /^\.tsx?/;

const BABEL_TRANSFORMER_DIR = _path.default.dirname(__dirname);

async function load(config, options, logger) {
  var _ref, _ref2, _ref3, _ref4, _options$env$BABEL_EN;

  // Don't look for a custom babel config if inside node_modules
  if (!config.isSource) {
    return buildDefaultBabelConfig(options, config);
  } // If we are in a monorepo, also find .babelrc configs in the sub packages.


  let babelrcRoots = [options.projectRoot];
  let packageJSONPath = await (0, _utils.resolveConfig)(options.inputFS, config.searchPath, ['package.json']);

  if (packageJSONPath) {
    let packageRoot = _path.default.dirname(packageJSONPath);

    if (packageRoot && packageRoot !== options.projectRoot) {
      babelrcRoots.push(packageRoot);
    }
  }

  let babelCore = await options.packageManager.require('@babel/core', config.searchPath, {
    range: _constants.BABEL_RANGE,
    autoinstall: options.autoinstall
  });
  let partialConfig = babelCore.loadPartialConfig({
    filename: config.searchPath,
    cwd: _path.default.dirname(config.searchPath),
    root: options.projectRoot,
    babelrcRoots,
    envName: (_ref = (_ref2 = (_ref3 = (_ref4 = (_options$env$BABEL_EN = options.env.BABEL_ENV) !== null && _options$env$BABEL_EN !== void 0 ? _options$env$BABEL_EN : process.env.BABEL_ENV) !== null && _ref4 !== void 0 ? _ref4 : options.env.NODE_ENV) !== null && _ref3 !== void 0 ? _ref3 : process.env.NODE_ENV) !== null && _ref2 !== void 0 ? _ref2 : options.mode === 'production' || options.mode === 'development' ? options.mode : null) !== null && _ref !== void 0 ? _ref : 'development'
  }); // loadPartialConfig returns null when the file should explicitly not be run through babel (ignore/exclude)

  if (partialConfig == null) {} else if (partialConfig.hasFilesystemConfig()) {
    config.setResult({
      internal: false,
      config: partialConfig.options,
      targets: (0, _utils2.enginesToBabelTargets)(config.env)
    });
    let {
      babelrc: babelrcPath,
      config: configPath
    } = partialConfig;
    let {
      canBeRehydrated,
      dependsOnRelative,
      dependsOnLocal
    } = getStats(partialConfig.options);
    let configIsJS = typeof babelrcPath === 'string' && _path.default.extname(babelrcPath) === '.js' || typeof configPath === 'string' && _path.default.extname(configPath) === '.js';

    if (configIsJS) {
      logger.verbose({
        message: 'WARNING: Using a JavaScript Babel config file means losing out on some caching features of Parcel. Try using a .babelrc file instead.'
      });
      config.shouldInvalidateOnStartup(); // babel.config.js files get required by @babel/core so there's no use in setting resolved path for watch mode invalidation
    } else {
      config.addIncludedFile(typeof babelrcPath === 'string' ? babelrcPath : configPath);
    }

    if (babelrcPath && (await isExtended())) {
      logger.verbose({
        message: 'WARNING: You are using `extends` in your Babel config, which means you are losing out on some of the caching features of Parcel. Maybe try using a reusable preset instead.'
      });
      config.shouldInvalidateOnStartup();
    }

    if (dependsOnRelative || dependsOnLocal) {
      logger.verbose({
        message: 'WARNING: It looks like you are using local Babel plugins or presets. You will need to run with the `--no-cache` option in order to pick up changes to these until their containing package versions are bumped.'
      });
    }

    if (canBeRehydrated) {
      await definePluginDependencies(config);
      config.setResultHash((0, _utils.md5FromObject)(partialConfig.options));
    } else {
      logger.verbose({
        message: 'WARNING: You are using `require` to configure Babel plugins or presets. This means Babel transformations cannot be cached and will run on each build. Please use strings to configure Babel instead.'
      });
      config.setResultHash(JSON.stringify(Date.now()));
      config.shouldInvalidateOnStartup();
    }
  } else {
    await buildDefaultBabelConfig(options, config);
  }
}

async function buildDefaultBabelConfig(options, config) {
  let babelOptions;

  if (_path.default.extname(config.searchPath).match(TYPESCRIPT_EXTNAME_RE)) {
    babelOptions = (0, _typescript.default)(config);
  } else {
    babelOptions = (0, _flow.default)(config);
  }

  let babelTargets;
  let envOptions = await (0, _env.default)(config);

  if (envOptions != null) {
    babelTargets = envOptions.targets;
    babelOptions = mergeOptions(babelOptions, {
      presets: envOptions.presets
    });
  }

  babelOptions = mergeOptions(babelOptions, (await (0, _jsx.default)(options, config)));

  if (babelOptions != null) {
    babelOptions.presets = (babelOptions.presets || []).map(preset => bundledBabelCore.createConfigItem(preset, {
      type: 'preset',
      dirname: BABEL_TRANSFORMER_DIR
    }));
    babelOptions.plugins = (babelOptions.plugins || []).map(plugin => bundledBabelCore.createConfigItem(plugin, {
      type: 'plugin',
      dirname: BABEL_TRANSFORMER_DIR
    }));
  }

  config.setResult({
    internal: true,
    config: babelOptions,
    targets: babelTargets
  });
  await definePluginDependencies(config);
}

function mergeOptions(result, config) {
  if (!config || (!config.presets || config.presets.length === 0) && (!config.plugins || config.plugins.length === 0)) {
    return result;
  }

  let merged = result;

  if (merged) {
    merged.presets = (merged.presets || []).concat(config.presets || []);
    merged.plugins = (merged.plugins || []).concat(config.plugins || []);
  } else {
    result = config;
  }

  return result;
}

function getStats(options) {
  let canBeRehydrated = true;
  let dependsOnRelative = false;
  let dependsOnLocal = false;
  let configItems = [...options.presets, ...options.plugins];

  for (let configItem of configItems) {
    if (!configItem.file) {
      canBeRehydrated = false;
    } else if (configItem.file.request.startsWith('.')) {
      dependsOnRelative = true;
    } else if (isLocal()) {
      dependsOnLocal = true;
    }
  }

  return {
    canBeRehydrated,
    dependsOnRelative,
    dependsOnLocal
  };
}

function isExtended()
/* babelrcPath */
{
  // TODO: read and parse babelrc and check to see if extends property exists
  // need access to fs in case of memory filesystem
  return false;
}

function isLocal()
/* configItemPath */
{
  // TODO: check if realpath is different, need access to fs in case of memory filesystem
  return false;
}

function preSerialize(config) {
  let babelConfig = config.result.config;

  if (babelConfig == null) {
    return;
  } // ConfigItem.value is a function which the v8 serializer chokes on
  // It is being ommited here and will be rehydrated later using the path provided by ConfigItem.file


  babelConfig.presets = (babelConfig.presets || []).map(({
    options,
    dirname,
    name,
    file
  }) => ({
    options,
    dirname,
    name,
    file
  }));
  babelConfig.plugins = (babelConfig.plugins || []).map(({
    options,
    dirname,
    name,
    file
  }) => ({
    options,
    dirname,
    name,
    file
  }));
}

async function definePluginDependencies(config) {
  let babelConfig = config.result.config;

  if (babelConfig == null) {
    return;
  }

  let configItems = [...babelConfig.presets, ...babelConfig.plugins];
  await Promise.all(configItems.map(async configItem => {
    let pkg = (0, _nullthrows.default)((await config.getConfigFrom(configItem.file.resolved, ['package.json'], {
      parse: true
    }))).contents;
    config.addDevDependency(pkg.name, pkg.version);
  }));
}

async function postDeserialize(config, options) {
  let babelCore = config.result.internal ? bundledBabelCore : await options.packageManager.require('@babel/core', config.searchPath, {
    autoinstall: options.autoinstall
  });
  config.result.config.presets = await Promise.all(config.result.config.presets.map(async configItem => {
    let value = await options.packageManager.require(configItem.file.resolved, config.searchPath, {
      autoinstall: options.autoinstall
    });
    value = value.default ? value.default : value;
    return babelCore.createConfigItem([value, configItem.options], {
      type: 'preset',
      dirname: configItem.dirname
    });
  }));
  config.result.config.plugins = await Promise.all(config.result.config.plugins.map(async configItem => {
    let value = await options.packageManager.require(configItem.file.resolved, config.searchPath, {
      autoinstall: options.autoinstall
    });
    value = value.default ? value.default : value;
    return babelCore.createConfigItem([value, configItem.options], {
      type: 'plugin',
      dirname: configItem.dirname
    });
  }));
}