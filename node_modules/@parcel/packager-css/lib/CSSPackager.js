"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _sourceMap = _interopRequireDefault(require("@parcel/source-map"));

var _plugin = require("@parcel/plugin");

var _utils = require("@parcel/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = new _plugin.Packager({
  async package({
    bundle,
    bundleGraph,
    getInlineBundleContents,
    options,
    getSourceMapReference
  }) {
    let queue = new _utils.PromiseQueue({
      maxConcurrent: 32
    });
    bundle.traverseAssets({
      exit: asset => {
        // Figure out which media types this asset was imported with.
        // We only want to import the asset once, so group them all together.
        let media = [];

        for (let dep of bundleGraph.getIncomingDependencies(asset)) {
          if (!dep.meta.media) {
            // Asset was imported without a media type. Don't wrap in @media.
            media.length = 0;
            break;
          }

          media.push(dep.meta.media);
        }

        queue.add(() => Promise.all([asset, asset.getCode().then(css => {
          if (media.length) {
            return `@media ${media.join(', ')} {\n${css}\n}\n`;
          }

          return css;
        }), options.sourceMaps && asset.getMapBuffer()]));
      }
    });
    let outputs = await queue.run();
    let contents = '';
    let map = new _sourceMap.default();
    let lineOffset = 0;

    for (let [asset, code, mapBuffer] of outputs) {
      contents += code + '\n';

      if (options.sourceMaps) {
        if (mapBuffer) {
          map.addBufferMappings(mapBuffer, lineOffset);
        } else {
          map.addEmptyMap(_path.default.relative(options.projectRoot, asset.filePath).replace(/\\+/g, '/'), code, lineOffset);
        }

        lineOffset += (0, _utils.countLines)(code);
      }
    }

    if (options.sourceMaps) {
      let reference = await getSourceMapReference(map);

      if (reference != null) {
        contents += '/*# sourceMappingURL=' + reference + ' */\n';
      }
    }

    ({
      contents,
      map
    } = (0, _utils.replaceURLReferences)({
      bundle,
      bundleGraph,
      contents,
      map
    }));
    return (0, _utils.replaceInlineReferences)({
      bundle,
      bundleGraph,
      contents,
      getInlineBundleContents,
      getInlineReplacement: (dep, inlineType, contents) => ({
        from: dep.id,
        to: contents
      }),
      map
    });
  }

});

exports.default = _default;