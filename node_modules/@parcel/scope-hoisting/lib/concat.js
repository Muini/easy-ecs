"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concat = concat;

var _parser = require("@babel/parser");

var _path = _interopRequireDefault(require("path"));

var t = _interopRequireWildcard(require("@babel/types"));

var _babylonWalk = require("@parcel/babylon-walk");

var _utils = require("@parcel/utils");

var _assert = _interopRequireDefault(require("assert"));

var _fs = _interopRequireDefault(require("fs"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _utils2 = require("./utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const HELPERS_PATH = _path.default.join(__dirname, 'helpers.js');

const HELPERS = parse(_fs.default.readFileSync(_path.default.join(__dirname, 'helpers.js'), 'utf8'), HELPERS_PATH);

const PRELUDE_PATH = _path.default.join(__dirname, 'prelude.js');

const PRELUDE = parse(_fs.default.readFileSync(_path.default.join(__dirname, 'prelude.js'), 'utf8'), PRELUDE_PATH);

// eslint-disable-next-line no-unused-vars
async function concat({
  bundle,
  bundleGraph,
  options,
  wrappedAssets
}) {
  let queue = new _utils.PromiseQueue({
    maxConcurrent: 32
  });
  bundle.traverse((node, shouldWrap) => {
    switch (node.type) {
      case 'dependency':
        // Mark assets that should be wrapped, based on metadata in the incoming dependency tree
        if (shouldWrap || node.value.meta.shouldWrap) {
          let resolved = bundleGraph.getDependencyResolution(node.value, bundle);

          if (resolved && resolved.sideEffects) {
            wrappedAssets.add(resolved.id);
          }

          return true;
        }

        break;

      case 'asset':
        queue.add(() => processAsset(options, bundle, node.value, wrappedAssets));
    }
  });
  let outputs = new Map((await queue.run()));
  let result = [...HELPERS];

  if ((0, _utils2.needsPrelude)(bundle, bundleGraph)) {
    result.unshift(...PRELUDE);
  }

  let usedExports = getUsedExports(bundle, bundleGraph); // Node: for each asset, the order of `$parcel$require` calls and the corresponding
  // `asset.getDependencies()` must be the same!

  bundle.traverseAssets({
    enter(asset, context) {
      if (shouldSkipAsset(bundleGraph, asset, usedExports)) {
        return context;
      }

      return {
        parent: context && context.children,
        children: new Map()
      };
    },

    exit(asset, context) {
      if (!context || shouldSkipAsset(bundleGraph, asset, usedExports)) {
        return;
      }

      let statements = (0, _nullthrows.default)(outputs.get(asset.id));
      let statementIndices = new Map();

      for (let i = 0; i < statements.length; i++) {
        let statement = statements[i];

        if ((0, t.isVariableDeclaration)(statement) || (0, t.isExpressionStatement)(statement)) {
          for (let depAsset of findRequires(bundle, bundleGraph, asset, statement)) {
            if (!statementIndices.has(depAsset.id)) {
              statementIndices.set(depAsset.id, i);
            }
          }
        }
      }

      for (let [assetId, ast] of [...context.children].reverse()) {
        let index = statementIndices.has(assetId) ? (0, _nullthrows.default)(statementIndices.get(assetId)) : 0;
        statements.splice(index, 0, ...ast);
      } // If this module is referenced by another JS bundle, or is an entry module in a child bundle,
      // add code to register the module with the module system.


      if (context.parent) {
        context.parent.set(asset.id, statements);
      } else {
        result.push(...statements);
      }
    }

  });
  return t.file(t.program(result));
}

async function processAsset(options, bundle, asset, wrappedAssets) {
  let statements;

  if (asset.astGenerator && asset.astGenerator.type === 'babel') {
    let ast = await asset.getAST();
    statements = t.cloneNode((0, _nullthrows.default)(ast).program.program).body;
  } else {
    let code = await asset.getCode();
    statements = parse(code, (0, _utils.relativeUrl)(options.projectRoot, asset.filePath));
  }

  if (wrappedAssets.has(asset.id)) {
    statements = wrapModule(asset, statements);
  }

  if (statements[0]) {
    t.addComment(statements[0], 'leading', ` ASSET: ${asset.filePath}`, true);
  }

  return [asset.id, statements];
}

function parse(code, sourceFilename) {
  let ast = (0, _parser.parse)(code, {
    sourceFilename,
    allowReturnOutsideFunction: true,
    plugins: ['dynamicImport']
  });
  return ast.program.body;
}

function getUsedExports(bundle, bundleGraph) {
  let usedExports = new Map();
  let entry = bundle.getMainEntry();

  if (entry) {
    for (let {
      asset,
      symbol
    } of bundleGraph.getExportedSymbols(entry)) {
      if (symbol) {
        markUsed(asset, symbol);
      }
    }
  }

  bundle.traverseAssets(asset => {
    for (let dep of bundleGraph.getDependencies(asset)) {
      let resolvedAsset = bundleGraph.getDependencyResolution(dep, bundle);

      if (!resolvedAsset) {
        continue;
      }

      for (let [symbol, {
        local
      }] of dep.symbols) {
        if (local === '*') {
          continue;
        }

        if (symbol === '*') {
          for (let {
            asset,
            symbol
          } of bundleGraph.getExportedSymbols(resolvedAsset)) {
            if (symbol) {
              markUsed(asset, symbol);
            }
          }
        }

        markUsed(resolvedAsset, symbol);
      }
    } // If the asset is referenced by another bundle, include all exports.


    if (bundleGraph.isAssetReferencedByDependant(bundle, asset)) {
      markUsed(asset, '*');

      for (let {
        asset: a,
        symbol
      } of bundleGraph.getExportedSymbols(asset)) {
        if (symbol) {
          markUsed(a, symbol);
        }
      }
    }
  });

  function markUsed(asset, symbol) {
    let resolved = bundleGraph.resolveSymbol(asset, symbol);
    let used = usedExports.get(resolved.asset.id);

    if (!used) {
      used = new Set();
      usedExports.set(resolved.asset.id, used);
    }

    used.add(resolved.exportSymbol);
  }

  return usedExports;
}

function shouldSkipAsset(bundleGraph, asset, usedExports) {
  return asset.sideEffects === false && !asset.meta.isCommonJS && (!usedExports.has(asset.id) || (0, _nullthrows.default)(usedExports.get(asset.id)).size === 0) && !bundleGraph.getIncomingDependencies(asset).find(d => // Don't exclude assets that was imported as a wildcard
  d.symbols.hasExportSymbol('*'));
}

const FIND_REQUIRES_VISITOR = {
  CallExpression(node, {
    bundle,
    bundleGraph,
    asset,
    result
  }) {
    let {
      arguments: args,
      callee
    } = node;

    if (!(0, t.isIdentifier)(callee)) {
      return;
    }

    if (callee.name === '$parcel$require') {
      let [, src] = args;
      (0, _assert.default)((0, t.isStringLiteral)(src));
      let dep = bundleGraph.getDependencies(asset).find(dep => dep.moduleSpecifier === src.value);

      if (!dep) {
        throw new Error(`Could not find dep for "${src.value}`);
      } // can be undefined if AssetGraph#resolveDependency optimized
      // ("deferred") this dependency away as an unused reexport


      let resolution = bundleGraph.getDependencyResolution(dep, bundle);

      if (resolution) {
        result.push(resolution);
      }
    }
  }

};

function findRequires(bundle, bundleGraph, asset, ast) {
  let result = [];
  (0, _babylonWalk.simple)(ast, FIND_REQUIRES_VISITOR, {
    asset,
    bundle,
    bundleGraph,
    result
  });
  return result;
} // Toplevel var/let/const declarations, function declarations and all `var` declarations
// in a non-function scope need to be hoisted.


const WRAP_MODULE_VISITOR = {
  VariableDeclaration(path, {
    decls
  }) {
    // $FlowFixMe
    let {
      node,
      parent
    } = path;
    let isParentForX = (0, t.isForInStatement)(parent, {
      left: node
    }) || (0, t.isForOfStatement)(parent, {
      left: node
    });
    let isParentFor = (0, t.isForStatement)(parent, {
      init: node
    });

    if (node.kind === 'var' || (0, t.isProgram)(path.parent)) {
      let replace = [];

      for (let decl of node.declarations) {
        let {
          id,
          init
        } = decl;

        if ((0, t.isObjectPattern)(id) || (0, t.isArrayPattern)(id)) {
          // $FlowFixMe it is an identifier
          let ids = Object.values(t.getBindingIdentifiers(id));

          for (let prop of ids) {
            decls.push(t.variableDeclarator(prop));
          }
        } else {
          decls.push(t.variableDeclarator(id));
          (0, _assert.default)(t.isIdentifier(id));
        }

        if (isParentForX) {
          replace.push(id);
        } else if (init) {
          replace.push(t.assignmentExpression('=', id, init));
        }
      }

      if (replace.length > 0) {
        let n = replace.length > 1 ? t.sequenceExpression(replace) : replace[0];

        if (!(isParentFor || isParentForX)) {
          n = t.expressionStatement(n);
        }

        path.replaceWith(n);
      } else {
        path.remove();
      }
    }

    path.skip();
  },

  FunctionDeclaration(path, {
    fns
  }) {
    fns.push(path.node);
    path.remove();
  },

  ClassDeclaration(path, {
    decls
  }) {
    // $FlowFixMe
    let {
      node
    } = path;
    let {
      id
    } = node;
    (0, _assert.default)((0, t.isIdentifier)(id)); // Class declarations are not hoisted (they behave like `let`). We declare a variable
    // outside the function and convert to a class expression assignment.

    decls.push(t.variableDeclarator(id));
    path.replaceWith(t.expressionStatement(t.assignmentExpression('=', id, t.toExpression(node))));
    path.skip();
  },

  'Function|Class'(path) {
    path.skip();
  },

  shouldSkip(node) {
    return t.isExpression(node);
  }

};

function wrapModule(asset, statements) {
  let decls = [];
  let fns = [];
  let program = t.program(statements);
  (0, _babylonWalk.traverse)(program, WRAP_MODULE_VISITOR, {
    decls,
    fns
  });
  let executed = (0, _utils2.getName)(asset, 'executed');
  decls.push(t.variableDeclarator(t.identifier(executed), t.booleanLiteral(false)));
  let execId = (0, _utils2.getIdentifier)(asset, 'exec');
  let exec = t.functionDeclaration(execId, [], t.blockStatement(program.body));
  let init = t.functionDeclaration((0, _utils2.getIdentifier)(asset, 'init'), [], t.blockStatement([t.ifStatement(t.unaryExpression('!', t.identifier(executed)), t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.identifier(executed), t.booleanLiteral(true))), t.expressionStatement(t.callExpression(execId, []))])), t.returnStatement(t.identifier((0, _utils2.assertString)(asset.meta.exportsIdentifier)))]));
  return [t.variableDeclaration('var', decls), ...fns, exec, init];
}