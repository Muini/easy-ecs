"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generate = generate;

var _generator = _interopRequireDefault(require("@babel/generator"));

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _utils = require("./utils");

var _sourceMap = _interopRequireDefault(require("@parcel/source-map"));

var t = _interopRequireWildcard(require("@babel/types"));

var _template = _interopRequireDefault(require("@babel/template"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const REGISTER_TEMPLATE = _template.default.statement(`(function() {
  function $parcel$bundleWrapper() {
    if ($parcel$bundleWrapper._executed) return;
    STATEMENTS;
    $parcel$bundleWrapper._executed = true;
  }
  var $parcel$referencedAssets = REFERENCED_IDS;
  for (var $parcel$i = 0; $parcel$i < $parcel$referencedAssets.length; $parcel$i++) {
    parcelRequire.registerBundle($parcel$referencedAssets[$parcel$i], $parcel$bundleWrapper);
  }
})()`);

const WRAPPER_TEMPLATE = _template.default.statement('(function () { STATEMENTS; })()');

function generate({
  bundleGraph,
  bundle,
  ast,
  referencedAssets,
  options
}) {
  let interpreter;

  if (!bundle.target.env.isBrowser()) {
    let _interpreter = (0, _nullthrows.default)(bundle.getMainEntry()).meta.interpreter;
    (0, _assert.default)(_interpreter == null || typeof _interpreter === 'string');
    interpreter = _interpreter;
  }

  let isAsync = !(0, _utils.isEntry)(bundle, bundleGraph); // Wrap async bundles in a closure and register with parcelRequire so they are executed
  // at the right time (after other bundle dependencies are loaded).

  let statements = ast.program.body;

  if (bundle.env.outputFormat === 'global') {
    statements = isAsync ? [REGISTER_TEMPLATE({
      STATEMENTS: statements,
      REFERENCED_IDS: t.arrayExpression([bundle.getMainEntry(), ...referencedAssets].filter(Boolean).map(asset => t.stringLiteral(asset.id)))
    })] : [WRAPPER_TEMPLATE({
      STATEMENTS: statements
    })];
  }

  ast = t.file(t.program(statements, [], bundle.env.outputFormat === 'esmodule' ? 'module' : 'script', interpreter ? t.interpreterDirective(interpreter) : null));
  let {
    code,
    rawMappings
  } = (0, _generator.default)(ast, {
    sourceMaps: options.sourceMaps,
    minified: bundle.env.minify,
    comments: true // retain /*@__PURE__*/ comments for terser

  });
  let map = null;

  if (options.sourceMaps && rawMappings != null) {
    map = new _sourceMap.default();
    map.addIndexedMappings(rawMappings);
  }

  return {
    contents: code,
    map
  };
}