"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateBundleImports = generateBundleImports;
exports.generateExternalImport = generateExternalImport;
exports.generateExports = generateExports;

var t = _interopRequireWildcard(require("@babel/types"));

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _path = require("path");

var _utils = require("@parcel/utils");

var _renamer = _interopRequireDefault(require("../renamer"));

var _utils2 = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function generateBundleImports(from, {
  bundle,
  assets
}, path) {
  let specifiers = [...assets].map(asset => {
    let id = (0, _utils2.getName)(asset, 'init');
    return t.importSpecifier(t.identifier(id), t.identifier(id));
  });
  let [decl] = path.unshiftContainer('body', [t.importDeclaration(specifiers, t.stringLiteral((0, _utils.relativeBundlePath)(from, bundle)))]);

  for (let spec of decl.get('specifiers')) {
    (0, _utils2.removeReplaceBinding)(path.scope, spec.node.local.name, spec, 'module');
  }
}

function generateExternalImport(bundle, external, path) {
  let {
    source,
    specifiers,
    isCommonJS
  } = external;
  let defaultSpecifier = null;
  let namespaceSpecifier = null;
  let namedSpecifiers = [];

  for (let [imported, symbol] of specifiers) {
    if (imported === 'default' || isCommonJS) {
      defaultSpecifier = t.importDefaultSpecifier(t.identifier(symbol));
    } else if (imported === '*') {
      namespaceSpecifier = t.importNamespaceSpecifier(t.identifier(symbol));
    } else {
      namedSpecifiers.push(t.importSpecifier(t.identifier(symbol), t.identifier(imported)));
    }
  }

  let statements = []; // ESModule syntax allows combining default and namespace specifiers, or default and named, but not all three.

  if (namespaceSpecifier) {
    let s = [namespaceSpecifier];

    if (defaultSpecifier) {
      s.unshift(defaultSpecifier);
    }

    statements.push(t.importDeclaration(s, t.stringLiteral(source)));
  } else if (defaultSpecifier) {
    namedSpecifiers.unshift(defaultSpecifier);
  }

  if (namedSpecifiers.length > 0 || statements.length === 0) {
    statements.push(t.importDeclaration(namedSpecifiers, t.stringLiteral(source)));
  }

  let decls = path.unshiftContainer('body', statements);

  for (let decl of decls) {
    let specifiers = decl.get('specifiers');

    for (let specifier of specifiers) {
      for (let name of Object.keys(specifier.getBindingIdentifiers())) {
        (0, _utils2.removeReplaceBinding)(path.scope, name, specifier, 'module');
      }
    }
  }
}

function generateExports(bundleGraph, bundle, referencedAssets, programPath, replacements, options) {
  // maps the bundles's export symbols to the bindings
  let exportedIdentifiers = new Map();
  let entry = bundle.getMainEntry();

  if (entry) {
    for (let {
      exportAs,
      exportSymbol,
      symbol,
      asset,
      loc
    } of bundleGraph.getExportedSymbols(entry)) {
      if (symbol != null) {
        symbol = replacements.get(symbol) || symbol; // Map CommonJS module.exports assignments to default ESM exports for interop

        if (exportAs === '*') {
          exportAs = 'default';
        } // If there is an existing binding with the exported name (e.g. an import),
        // rename it so we can use the name for the export instead.


        if (programPath.scope.hasBinding(exportAs) && exportAs !== symbol) {
          (0, _renamer.default)(programPath.scope, exportAs, programPath.scope.generateUid(exportAs));
        }

        exportedIdentifiers.set(exportAs, symbol);
      } else if (symbol === null) {
        // TODO `meta.exportsIdentifier[exportSymbol]` should be exported
        let relativePath = (0, _path.relative)(options.projectRoot, asset.filePath);
        throw (0, _utils2.getThrowableDiagnosticForNode)(`${relativePath} couldn't be statically analyzed when importing '${exportSymbol}'`, entry.filePath, loc);
      } else {
        let relativePath = (0, _path.relative)(options.projectRoot, asset.filePath);
        throw (0, _utils2.getThrowableDiagnosticForNode)(`${relativePath} does not export '${exportSymbol}'`, entry.filePath, loc);
      }
    }
  }

  for (let asset of referencedAssets) {
    let exportsId = (0, _utils2.getName)(asset, 'init');
    exportedIdentifiers.set(exportsId, exportsId);
  }

  let exported = new Set();
  programPath.traverse({
    Declaration(path) {
      if (path.isExportDeclaration() || path.parentPath.isExportDeclaration()) {
        return;
      }

      let {
        node
      } = path;
      let bindingIdentifiers = path.getBindingIdentifierPaths(false, true);
      let ids = Object.keys(bindingIdentifiers);

      if (ids.length === 0) {
        return;
      }

      ids.sort();
      let exportedIdentifiersFiltered = [...exportedIdentifiers.entries()].filter(([exportSymbol, symbol]) => exportSymbol !== 'default' && ids.includes(symbol)).sort(([, a], [, b]) => a > b ? -1 : a < b ? 1 : 0);
      let exportedSymbolsBindings = exportedIdentifiersFiltered.map(([, symbol]) => symbol);
      let exportedSymbols = exportedIdentifiersFiltered.map(([exportSymbol]) => exportSymbol);
      let defaultExport = exportedIdentifiers.get('default');

      if (!ids.includes(defaultExport)) {
        defaultExport = null;
      } // If all exports in the binding are named exports, export the entire declaration.
      // Also rename all of the identifiers to their exported name.


      if (areArraysStrictlyEqual(ids, exportedSymbolsBindings) && !path.isImportDeclaration()) {
        let [decl] = path.replaceWith(t.exportNamedDeclaration(node, []));

        for (let sym of exportedSymbols) {
          let id = (0, _nullthrows.default)(exportedIdentifiers.get(sym));
          id = replacements.get(id) || id;
          (0, _nullthrows.default)(path.scope.getBinding(id)).reference(decl);
          (0, _renamer.default)(path.scope, id, sym);
          replacements.set(id, sym);
          exported.add(sym);
        } // If the default export is part of the declaration, add it as well


        if (defaultExport != null) {
          defaultExport = replacements.get(defaultExport) || defaultExport;
          let binding = path.scope.getBinding(defaultExport);
          let insertPath = path;

          if (binding && !binding.constant) {
            insertPath = binding.constantViolations[binding.constantViolations.length - 1];
          }

          let [decl] = insertPath.insertAfter(t.exportDefaultDeclaration(t.identifier(defaultExport)));
          binding === null || binding === void 0 ? void 0 : binding.reference(decl);
        } // If there is only a default export, export the entire declaration.

      } else if (ids.length === 1 && defaultExport != null && !(0, t.isVariableDeclaration)(node) && !(0, t.isImportDeclaration)(node)) {
        (0, _assert.default)((0, t.isFunctionDeclaration)(node) || (0, t.isClassDeclaration)(node));
        let binding = (0, _nullthrows.default)(path.scope.getBinding((0, _nullthrows.default)(node.id).name)); // We don't update the references in `node` itself (e.g. function body), because this statement
        // will never be removed and therefore the shaking doesn't need correct
        // information. All existing references in `node` are "dead" but will also never be removed.

        let [decl] = path.replaceWith(t.exportDefaultDeclaration(node));
        binding.path = decl.get('declaration');
        binding.reference(decl); // Otherwise, add export statements after for each identifier.
      } else {
        if (defaultExport != null) {
          defaultExport = replacements.get(defaultExport) || defaultExport;
          let binding = path.scope.getBinding(defaultExport);
          let insertPath = path;

          if (binding && !binding.constant) {
            insertPath = binding.constantViolations[binding.constantViolations.length - 1];
          }

          let [decl] = insertPath.insertAfter(t.exportDefaultDeclaration(t.identifier(defaultExport)));
          binding === null || binding === void 0 ? void 0 : binding.reference(decl.get('declaration'));
        }

        if (exportedSymbols.length > 0) {
          let [decl] = path.insertAfter(t.exportNamedDeclaration(null, []));

          for (let sym of exportedSymbols) {
            var _path$scope$getBindin;

            let id = (0, _nullthrows.default)(exportedIdentifiers.get(sym));
            id = replacements.get(id) || id;
            (0, _renamer.default)(path.scope, id, sym);
            replacements.set(id, sym);
            exported.add(sym);
            let [spec] = decl.unshiftContainer('specifiers', [t.exportSpecifier(t.identifier(sym), t.identifier(sym))]);
            (_path$scope$getBindin = path.scope.getBinding(sym)) === null || _path$scope$getBindin === void 0 ? void 0 : _path$scope$getBindin.reference(spec.get('local'));
          }
        }
      }
    }

  });
  return exported;
}

function areArraysStrictlyEqual(a, b) {
  return a.length === b.length && a.every(function (a_v, i) {
    return a_v === b[i];
  });
}