"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateBundleImports = generateBundleImports;
exports.generateExternalImport = generateExternalImport;
exports.generateExports = generateExports;

var t = _interopRequireWildcard(require("@babel/types"));

var _template = _interopRequireDefault(require("@babel/template"));

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _path = require("path");

var _utils = require("@parcel/utils");

var _renamer = _interopRequireDefault(require("../renamer"));

var _utils2 = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const REQUIRE_TEMPLATE = _template.default.expression('require(BUNDLE)');

const EXPORT_TEMPLATE = _template.default.statement('exports.NAME = IDENTIFIER;');

const MODULE_EXPORTS_TEMPLATE = _template.default.statement('module.exports = IDENTIFIER;');

const INTEROP_TEMPLATE = _template.default.expression('$parcel$interopDefault(MODULE)');

const ASSIGN_TEMPLATE = _template.default.statement('var SPECIFIERS = MODULE;');

const NAMESPACE_TEMPLATE = _template.default.expression('$parcel$exportWildcard(NAMESPACE, MODULE)'); // List of engines that support object destructuring syntax


const DESTRUCTURING_ENGINES = {
  chrome: '51',
  edge: '15',
  firefox: '53',
  safari: '10',
  node: '6.5',
  ios: '10',
  samsung: '5',
  opera: '38',
  electron: '1.2'
};

function generateDestructuringAssignment(env, specifiers, value, scope) {
  // If destructuring is not supported, generate a series of variable declarations
  // with member expressions for each property.
  if (!env.matchesEngines(DESTRUCTURING_ENGINES)) {
    let statements = [];

    if (!(0, t.isIdentifier)(value) && specifiers.length > 1) {
      let name = scope.generateUid();
      statements.push(ASSIGN_TEMPLATE({
        SPECIFIERS: t.identifier(name),
        MODULE: value
      }));
      value = t.identifier(name);
    }

    for (let specifier of specifiers) {
      (0, _assert.default)((0, t.isIdentifier)(specifier.value));
      statements.push(ASSIGN_TEMPLATE({
        SPECIFIERS: specifier.value,
        MODULE: t.memberExpression(value, specifier.key)
      }));
    }

    return statements;
  }

  return [ASSIGN_TEMPLATE({
    SPECIFIERS: t.objectPattern(specifiers),
    MODULE: value
  })];
}

function generateBundleImports(from, {
  bundle,
  assets
}, path) {
  let specifiers = [...assets].map(asset => {
    let id = (0, _utils2.getName)(asset, 'init');
    return t.objectProperty(t.identifier(id), t.identifier(id), false, true);
  });
  let expression = REQUIRE_TEMPLATE({
    BUNDLE: t.stringLiteral((0, _utils.relativeBundlePath)(from, bundle))
  });

  if (specifiers.length > 0) {
    let decls = path.unshiftContainer('body', generateDestructuringAssignment(bundle.env, specifiers, expression, path.scope));

    for (let decl of decls) {
      // every VariableDeclaration emitted by generateDestructuringAssignment has only
      // one VariableDeclarator
      let next = decl.get('declarations.0');

      for (let [name] of Object.entries(decl.getBindingIdentifierPaths())) {
        if (path.scope.hasOwnBinding(name)) {
          (0, _utils2.removeReplaceBinding)(path.scope, name, next);
        } else {
          path.scope.registerDeclaration(decl);
        }
      }
    }
  } else {
    path.unshiftContainer('body', [t.expressionStatement(expression)]);
  }
}

function generateExternalImport(bundle, external, path) {
  let {
    scope
  } = path;
  let {
    source,
    specifiers,
    isCommonJS
  } = external;
  let properties = [];
  let categories = new Set();

  for (let [imported, symbol] of specifiers) {
    if (imported === '*') {
      categories.add('namespace');
    } else if (imported === 'default') {
      categories.add('default');
    } else {
      categories.add('named');
      properties.push(t.objectProperty(t.identifier(imported), t.identifier(symbol), false, symbol === imported));
    }
  }

  let specifiersWildcard = specifiers.get('*');
  let specifiersDefault = specifiers.get('default');
  let statements = []; // Attempt to combine require calls as much as possible. Namespace, default, and named specifiers
  // cannot be combined, so in the case where we have more than one type, assign the require() result
  // to a variable first and then create additional variables for each specifier based on that.
  // Otherwise, if just one category is imported, just assign and require all at once.

  if (categories.size > 1) {
    let name = scope.generateUid(source);
    statements.push(ASSIGN_TEMPLATE({
      SPECIFIERS: t.identifier(name),
      MODULE: REQUIRE_TEMPLATE({
        BUNDLE: t.stringLiteral(source)
      })
    }));

    if (specifiersWildcard) {
      let value = t.identifier(name);

      if (!isCommonJS) {
        value = NAMESPACE_TEMPLATE({
          NAMESPACE: t.objectExpression([]),
          MODULE: value
        });
      }

      statements.push(ASSIGN_TEMPLATE({
        SPECIFIERS: t.identifier(specifiersWildcard),
        MODULE: value
      }));
    }

    if (specifiersDefault) {
      statements.push(ASSIGN_TEMPLATE({
        SPECIFIERS: t.identifier(specifiersDefault),
        MODULE: INTEROP_TEMPLATE({
          MODULE: t.identifier(name)
        })
      }));
    }

    if (properties.length > 0) {
      statements.push(...generateDestructuringAssignment(bundle.env, properties, t.identifier(name), scope));
    }
  } else if (specifiersDefault) {
    statements.push(ASSIGN_TEMPLATE({
      SPECIFIERS: t.identifier(specifiersDefault),
      MODULE: INTEROP_TEMPLATE({
        MODULE: REQUIRE_TEMPLATE({
          BUNDLE: t.stringLiteral(source)
        })
      })
    }));
  } else if (specifiersWildcard) {
    let require = REQUIRE_TEMPLATE({
      BUNDLE: t.stringLiteral(source)
    });

    if (!isCommonJS) {
      require = NAMESPACE_TEMPLATE({
        NAMESPACE: t.objectExpression([]),
        MODULE: require
      });
    }

    statements.push(ASSIGN_TEMPLATE({
      SPECIFIERS: t.identifier(specifiersWildcard),
      MODULE: require
    }));
  } else if (properties.length > 0) {
    statements.push(...generateDestructuringAssignment(bundle.env, properties, REQUIRE_TEMPLATE({
      BUNDLE: t.stringLiteral(source)
    }), scope));
  } else {
    statements.push(t.expressionStatement(REQUIRE_TEMPLATE({
      BUNDLE: t.stringLiteral(source)
    })));
  }

  let decls = path.unshiftContainer('body', statements);

  for (let decl of decls) {
    if ((0, t.isVariableDeclaration)(decl.node)) {
      let declarator = decl.get('declarations.0');

      for (let [name] of Object.entries(decl.getBindingIdentifierPaths())) {
        if (path.scope.hasOwnBinding(name)) {
          (0, _utils2.removeReplaceBinding)(path.scope, name, declarator);
        } else {
          // $FlowFixMe
          path.scope.registerBinding(decl.node.kind, declarator);
        }
      }

      if ((0, t.isCallExpression)(declarator.node.init)) {
        if (!(0, t.isIdentifier)(declarator.node.init.callee, {
          name: 'require'
        })) {
          // $parcel$exportWildcard or $parcel$interopDefault
          let id = declarator.get('init.callee');
          let {
            name
          } = id.node;
          (0, _nullthrows.default)(path.scope.getBinding(name)).reference(id);

          for (let arg of declarator.get('init.arguments')) {
            if ((0, t.isIdentifier)(arg.node)) {
              // $FlowFixMe
              (0, _nullthrows.default)(path.scope.getBinding(arg.node.name)).reference(arg);
            }
          }
        }
      } else if ((0, t.isIdentifier)(declarator.node.init)) {
        // a temporary variable for the transpiled destructuring assigment
        (0, _nullthrows.default)(path.scope.getBinding(declarator.node.init.name)).reference(declarator.get('init'));
      } else if ((0, t.isMemberExpression)(declarator.node.init) && (0, t.isIdentifier)(declarator.node.init.object)) {
        // (a temporary variable for the transpiled destructuring assigment).symbol
        (0, _nullthrows.default)(path.scope.getBinding(declarator.node.init.object.name)).reference(declarator.get('init.object'));
      }
    }
  }
}

function generateExports(bundleGraph, bundle, referencedAssets, path, replacements, options) {
  let exported = new Set();
  let statements = [];

  for (let asset of referencedAssets) {
    let id = (0, _utils2.getIdentifier)(asset, 'init');
    exported.add(id.name);
    statements.push(EXPORT_TEMPLATE({
      NAME: id,
      IDENTIFIER: id
    }));
  }

  let entry = bundle.getMainEntry();

  if (entry) {
    if (entry.meta.isCommonJS) {
      let exportsId = (0, _utils2.assertString)(entry.meta.exportsIdentifier);
      let binding = path.scope.getBinding(exportsId);

      if (binding) {
        // If the exports object is constant, then we can just remove it and rename the
        // references to the builtin CommonJS exports object. Otherwise, assign to module.exports.
        (0, _assert.default)((0, t.isVariableDeclarator)(binding.path.node));
        let init = binding.path.node.init;
        let isEmptyObject = init && (0, t.isObjectExpression)(init) && init.properties.length === 0;

        if (binding.constant && isEmptyObject) {
          for (let path of binding.referencePaths) {
            // This is never a ExportNamedDeclaration
            (0, _assert.default)((0, t.isIdentifier)(path.node));
            path.node.name = 'exports';
          }

          binding.path.remove();
          exported.add('exports');
        } else {
          exported.add(exportsId);
          statements.push(MODULE_EXPORTS_TEMPLATE({
            IDENTIFIER: t.identifier(exportsId)
          }));
        }
      }
    } else {
      for (let {
        exportAs,
        exportSymbol,
        symbol,
        asset,
        loc
      } of bundleGraph.getExportedSymbols(entry)) {
        if (symbol != null) {
          let hasReplacement = replacements.get(symbol);
          symbol = hasReplacement !== null && hasReplacement !== void 0 ? hasReplacement : symbol; // If there is an existing binding with the exported name (e.g. an import),
          // rename it so we can use the name for the export instead.

          if (path.scope.hasBinding(exportAs) && exportAs !== symbol) {
            (0, _renamer.default)(path.scope, exportAs, path.scope.generateUid(exportAs));
          }

          let binding = (0, _nullthrows.default)(path.scope.getBinding(symbol));

          if (!hasReplacement) {
            let id = !t.isValidIdentifier(exportAs) ? path.scope.generateUid(exportAs) : exportAs; // rename only once, avoid having to update `replacements` transitively

            (0, _renamer.default)(path.scope, symbol, id);
            replacements.set(symbol, id);
            symbol = id;
          }

          let [stmt] = binding.path.getStatementParent().insertAfter(EXPORT_TEMPLATE({
            NAME: t.identifier(exportAs),
            IDENTIFIER: t.identifier(symbol)
          }));
          binding.reference(stmt.get('expression.right')); // Exports other than the default export are live bindings. Insert an assignment
          // after each constant violation so this remains true.

          if (exportAs !== 'default') {
            for (let path of binding.constantViolations) {
              let [stmt] = path.insertAfter(EXPORT_TEMPLATE({
                NAME: t.identifier(exportAs),
                IDENTIFIER: t.identifier(symbol)
              }));
              binding.reference(stmt.get('expression.right'));
            }
          }
        } else if (symbol === null) {
          // TODO `meta.exportsIdentifier[exportSymbol]` should be exported
          let relativePath = (0, _path.relative)(options.projectRoot, asset.filePath);
          throw (0, _utils2.getThrowableDiagnosticForNode)(`${relativePath} couldn't be statically analyzed when importing '${exportSymbol}'`, entry.filePath, loc);
        } else {
          // Reexport that couldn't be resolved
          let relativePath = (0, _path.relative)(options.projectRoot, asset.filePath);
          throw (0, _utils2.getThrowableDiagnosticForNode)(`${relativePath} does not export '${exportSymbol}'`, entry.filePath, loc);
        }
      }
    }
  }

  let stmts = path.pushContainer('body', statements);

  for (let stmt of stmts) {
    let id = stmt.get('expression.right');
    (0, _nullthrows.default)(path.scope.getBinding(id.node.name)).reference(id);
  }

  return exported;
}