"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = treeShake;

var _types = require("@babel/types");

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This is a small small implementation of dead code removal specialized to handle
 * removing unused exports.
 */
function treeShake(scope, exportedIdentifiers, exportsMap) {
  // Keep passing over all bindings in the scope until we don't remove any.
  // This handles cases where we remove one binding which had a reference to
  // another one. That one will get removed in the next pass if it is now unreferenced.
  let removed;

  do {
    removed = false;
    Object.keys(scope.bindings).forEach(name => {
      let binding = getUnusedBinding(scope.path, name, exportsMap); // If it is not safe to remove the binding don't touch it.

      if (!binding || exportedIdentifiers.has(name)) {
        return;
      } // Remove the binding and all references to it.


      (0, _utils.pathRemove)(binding.path);
      [...binding.referencePaths, ...binding.constantViolations].forEach(p => remove(p, scope, exportsMap));
      scope.removeBinding(name);
      removed = true;
    });
  } while (removed);
} // Check if a binding is safe to remove and returns it if it is.


function getUnusedBinding(path, name, exportsMap) {
  let binding = path.scope.getBinding(name);

  if (!binding) {
    return null;
  }

  if (!isPure(binding)) {
    // declaration (~= init) isn't pure
    return null;
  }

  if (hasSideEffects(binding)) {
    // e.g.
    //    let foo = {};
    //    foo = window;
    //    foo.xyz = 2;
    //    console.log(window.xyz);
    return null;
  }

  if (!binding.referenced) {
    return binding;
  } // Is there any references which aren't simple assignments?


  let bailout = binding.referencePaths.some(path => !isExportAssignment(path, exportsMap) && !isWildcardDest(path));

  if (!bailout) {
    return binding;
  }

  return null;
}

function isPure(binding) {
  let {
    path
  } = binding;
  let {
    node
  } = path;

  if ((0, _types.isVariableDeclarator)(node) && (0, _types.isIdentifier)(node.id)) {
    let init = path.get('init');
    return init.isPure() || init.isIdentifier() || init.isThisExpression() || (0, _types.isVariableDeclarator)(node) && (0, _types.isIdentifier)(node.id, {
      name: '$parcel$global'
    });
  }

  return path.isPure();
}

function hasSideEffects(binding) {
  let {
    node
  } = binding.path;

  if ((0, _types.isVariableDeclarator)(node)) {
    return !((!binding.referenced || (0, _types.isObjectExpression)(node.init)) && (binding.constant || binding.constantViolations.every(({
      node
    }) => !(0, _types.isAssignmentExpression)(node) || (0, _types.isObjectExpression)(node.right))));
  }

  return false;
}

function isExportAssignment(path, exportsMap) {
  let {
    parent
  } = path; // match "path.foo = bar;", where path is a known exports identifier.

  if ((0, _types.isMemberExpression)(parent) && parent.object === path.node && (0, _types.isIdentifier)(path.node) && exportsMap.has(path.node.name) && ((0, _types.isIdentifier)(parent.property) && !parent.computed || (0, _types.isStringLiteral)(parent.property))) {
    let parentParent = path.parentPath.parent;
    return (0, _types.isAssignmentExpression)(parentParent) && parentParent.left === parent;
  }

  return false;
} // check if the argument appears as $parcel$exportWildcard(path, ...)


function isWildcardDest(path) {
  let parent = path.parent;
  return (0, _types.isCallExpression)(parent) && (0, _types.isIdentifier)(parent.callee, {
    name: '$parcel$exportWildcard'
  }) && parent.arguments[0] === path.node;
}

function remove(path, scope, exportsMap) {
  let {
    node,
    parent
  } = path;

  if ((0, _types.isAssignmentExpression)(node)) {
    let right;

    if ((0, _types.isSequenceExpression)(parent) && parent.expressions.length === 1) {
      // TODO missing test coverage
      // replace sequence expression with it's sole child
      path.parentPath.replaceWith(node);
      remove(path.parentPath, scope, exportsMap);
    } else if ( //e.g. `exports.foo = bar;`, `bar` needs to be pure (an Identifier isn't ?!)
    (0, _types.isExpressionStatement)(parent) && ((right = path.get('right')).isPure() || right.isIdentifier())) {
      (0, _utils.pathRemove)(path);
    } else {
      // right side isn't pure
      path.replaceWith(node.right);
    }
  } else if (isExportAssignment(path, exportsMap)) {
    remove(path.parentPath.parentPath, scope, exportsMap);
  } else if (isWildcardDest(path)) {
    let wildcard = path.parent;
    (0, _assert.default)((0, _types.isCallExpression)(wildcard));
    let src = wildcard.arguments[1];

    if ((0, _types.isCallExpression)(src)) {
      let {
        callee
      } = src;
      (0, _assert.default)((0, _types.isIdentifier)(callee) && callee.name); // keep `$...$init()` call

      (0, _utils.pathDereference)(path.parentPath);
      let [expr] = path.parentPath.replaceWith(src);
      (0, _nullthrows.default)(scope.getBinding(callee.name)).reference(expr.get('callee'));
    } else {
      (0, _assert.default)((0, _types.isIdentifier)(src) || (0, _types.isObjectExpression)(src) && src.properties.length === 0);
      remove(path.parentPath, scope, exportsMap);
    }
  } else if (!path.removed) {
    if ((0, _types.isSequenceExpression)(parent) && parent.expressions.length === 1) {
      // TODO missing test coverage
      // replace sequence expression with it's sole child
      path.parentPath.replaceWith(node);
      remove(path.parentPath, scope, exportsMap);
    } else {
      (0, _utils.pathRemove)(path);
    }
  }
}