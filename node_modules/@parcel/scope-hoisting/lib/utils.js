"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getName = getName;
exports.getIdentifier = getIdentifier;
exports.getExportIdentifier = getExportIdentifier;
exports.needsPrelude = needsPrelude;
exports.isEntry = isEntry;
exports.isReferenced = isReferenced;
exports.hasAsyncDescendant = hasAsyncDescendant;
exports.assertString = assertString;
exports.pathDereference = pathDereference;
exports.pathRemove = pathRemove;
exports.removeReplaceBinding = removeReplaceBinding;
exports.verifyScopeState = verifyScopeState;
exports.getThrowableDiagnosticForNode = getThrowableDiagnosticForNode;
exports.convertBabelLoc = convertBabelLoc;

var _babylonWalk = require("@parcel/babylon-walk");

var _diagnostic = _interopRequireDefault(require("@parcel/diagnostic"));

var t = _interopRequireWildcard(require("@babel/types"));

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _path = _interopRequireDefault(require("path"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getName(asset, type, ...rest) {
  return '$' + t.toIdentifier(asset.id) + '$' + type + (rest.length ? '$' + rest.map(name => name === 'default' ? name : t.toIdentifier(name)).join('$') : '');
}

function getIdentifier(asset, type, ...rest) {
  return t.identifier(getName(asset, type, ...rest));
}

function getExportIdentifier(asset, name) {
  return getIdentifier(asset, 'export', name);
}

function needsPrelude(bundle, bundleGraph) {
  if (bundle.env.outputFormat !== 'global') {
    return false;
  } // If this is an entry bundle and it is referenced by other bundles,
  // we need to add the prelude code, which allows registering modules dynamically at runtime.


  return isEntry(bundle, bundleGraph) && ( // If this bundle has an async descendant, it will use the JSRuntime,
  // which uses parcelRequire. It's also possible that the descendant needs
  // to register exports for its own descendants.
  hasAsyncDescendant(bundle, bundleGraph) || // If an asset in this bundle is referenced, this bundle will use
  //`parcelRequire.register` to register the asset.
  isReferenced(bundle, bundleGraph));
}

function isEntry(bundle, bundleGraph) {
  // If there is no parent JS bundle (e.g. in an HTML page), or environment is isolated (e.g. worker)
  // then this bundle is an "entry"
  return !bundleGraph.hasParentBundleOfType(bundle, 'js') || bundle.env.isIsolated();
}

function isReferenced(bundle, bundleGraph) {
  let isReferenced = false;
  bundle.traverseAssets((asset, _, actions) => {
    // A bundle is potentially referenced if any of its assets is referenced
    // by any of its siblings, descendants, siblings of descendants, or
    // descendants of siblings.
    if (bundleGraph.isAssetReferencedByDependant(bundle, asset)) {
      isReferenced = true;
      actions.stop();
    }
  });
  return isReferenced;
}

function hasAsyncDescendant(bundle, bundleGraph) {
  let _hasAsyncDescendant = false;
  bundleGraph.traverseBundles((b, _, actions) => {
    if (b.id === bundle.id) {
      return;
    }

    if (b.env.context !== bundle.env.context || b.type !== 'js') {
      actions.skipChildren();
      return;
    }

    if (b.getMainEntry()) {
      _hasAsyncDescendant = true;
      actions.stop();
    }
  }, bundle);
  return _hasAsyncDescendant;
}

function assertString(v) {
  (0, _assert.default)(typeof v === 'string');
  return v;
}

const DereferenceVisitor = {
  Identifier(node, scope) {
    dereferenceIdentifier(node, scope);
  }

}; // updates bindings in path.scope.getProgramParent()

function pathDereference(path) {
  (0, _babylonWalk.simple)(path.node, DereferenceVisitor, path.scope.getProgramParent());
} // like path.remove(), but updates bindings in path.scope.getProgramParent()


function pathRemove(path) {
  pathDereference(path);
  path.remove();
}

function dereferenceIdentifier(node, scope) {
  let binding = scope.getBinding(node.name);

  if (binding) {
    let i = binding.referencePaths.findIndex(v => v.node === node);

    if (i >= 0) {
      binding.dereference();
      binding.referencePaths.splice(i, 1);
      return;
    }

    let j = binding.constantViolations.findIndex(v => Object.values(v.getBindingIdentifiers()).includes(node));

    if (j >= 0) {
      binding.constantViolations.splice(j, 1);

      if (binding.constantViolations.length == 0) {
        binding.constant = true;
      }
    }
  }
}

function removeReplaceBinding(scope, name, newPath, newKind) {
  let binding = (0, _nullthrows.default)(scope.getBinding(name));
  let path = binding.path;
  let {
    node,
    parent
  } = path;
  (0, _assert.default)((0, t.isVariableDeclarator)(node) && (0, t.isVariableDeclaration)(parent) && !node.init); // `path.remove()`ing a declaration also removes the corresponding binding. But we want to keep
  // the binding and only replace the declaration. path._remove() merely removes the node in the AST.
  // $FlowFixMe

  path._remove();

  if (parent.declarations.length === 0) {
    path.parentPath.remove();
  }

  binding.path = newPath;
  binding.identifier = newPath.getBindingIdentifiers()[name];

  if (newKind) {
    binding.kind = newKind;
  }
}

function verifyScopeState(scope) {
  let oldBindings = scope.bindings;
  scope.crawl();
  let newBindings = scope.bindings;
  (0, _assert.default)(Object.keys(oldBindings).length === Object.keys(newBindings).length);

  for (let name of Object.keys(newBindings)) {
    (0, _assert.default)(newBindings[name], name);
    let {
      scope: aScope,
      constantViolations: aConstantViolations,
      referencePaths: aReferencePaths,
      identifier: aId,
      path: aPath,
      ...a
    } = oldBindings[name];
    let {
      scope: bScope,
      constantViolations: bConstantViolations,
      referencePaths: bReferencePaths,
      identifier: bId,
      path: bPath,
      ...b
    } = newBindings[name];
    (0, _assert.default)(aPath === bPath, name);
    (0, _assert.default)(aId === bId, name);
    (0, _assert.default)(aScope === bScope, name);

    _assert.default.deepStrictEqual(a, b, name);

    (0, _assert.default)(aConstantViolations.length === bConstantViolations.length, name);

    for (let p of bConstantViolations) {
      (0, _assert.default)(aConstantViolations.indexOf(p) >= 0, name);
    }

    (0, _assert.default)(aReferencePaths.length === bReferencePaths.length, name);

    for (let p of bReferencePaths) {
      (0, _assert.default)(aReferencePaths.indexOf(p) >= 0, name);
    }
  }
}

function getThrowableDiagnosticForNode(message, filePath, loc) {
  let diagnostic = {
    message,
    language: 'js'
  };

  if (filePath) {
    diagnostic.filePath = _path.default.normalize(filePath);
  }

  if (loc) {
    diagnostic.codeFrame = {
      codeHighlights: {
        start: {
          line: loc.start.line,
          column: loc.start.column + 1
        },
        // - Babel's columns are exclusive, ours are inclusive (column - 1)
        // - Babel has 0-based columns, ours are 1-based (column + 1)
        // = +-0
        end: loc.end
      }
    };
  }

  return new _diagnostic.default({
    diagnostic
  });
}

function convertBabelLoc(loc) {
  if (!loc || !loc.filename) return null;
  let {
    filename,
    start,
    end
  } = loc;
  return {
    filePath: _path.default.normalize(filename),
    start: {
      line: start.line,
      column: start.column
    },
    end: {
      line: end.line,
      column: end.column
    }
  };
}