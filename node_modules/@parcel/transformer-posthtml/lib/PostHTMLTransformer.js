"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _plugin = require("@parcel/plugin");

var _path = _interopRequireDefault(require("path"));

var _posthtml = _interopRequireDefault(require("posthtml"));

var _posthtmlParser = _interopRequireDefault(require("posthtml-parser"));

var _posthtmlRender = _interopRequireDefault(require("posthtml-render"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _semver = _interopRequireDefault(require("semver"));

var _loadPlugins = _interopRequireDefault(require("./loadPlugins"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = new _plugin.Transformer({
  async loadConfig({
    config
  }) {
    let configFile = await config.getConfig(['.posthtmlrc', '.posthtmlrc.js', 'posthtml.config.js'], {
      packageKey: 'posthtml'
    });

    if (configFile) {
      let isJavascript = _path.default.extname(configFile.filePath) === '.js';

      if (isJavascript) {
        config.shouldInvalidateOnStartup();
        config.shouldReload();
      } // tells posthtml that we have already called parse


      configFile.contents.skipParse = true;
      config.setResult({
        contents: configFile.contents,
        isSerialisable: !isJavascript
      });
    }
  },

  preSerializeConfig({
    config
  }) {
    if (!config.result) return; // Ensure we dont try to serialise functions

    if (!config.result.isSerialisable) {
      config.result.contents = {};
    }
  },

  canReuseAST({
    ast
  }) {
    return ast.type === 'posthtml' && _semver.default.satisfies(ast.version, '^0.4.0');
  },

  async parse({
    asset,
    config
  }) {
    // if we don't have a config it is posthtml is not configure, don't parse
    if (!config) {
      return;
    }

    return {
      type: 'posthtml',
      version: '0.4.1',
      program: (0, _posthtmlParser.default)((await asset.getCode()), {
        lowerCaseAttributeNames: true
      })
    };
  },

  async transform({
    asset,
    config,
    options
  }) {
    if (!config) {
      return [asset];
    } // load plugins


    const plugins = await (0, _loadPlugins.default)(config.contents.plugins, asset.filePath, options);
    let ast = (0, _nullthrows.default)((await asset.getAST()));
    let res = await (0, _posthtml.default)(plugins).process(ast.program, { ...config.contents,
      plugins
    });

    if (res.messages) {
      await Promise.all(res.messages.map(({
        type,
        file: filePath
      }) => {
        if (type === 'dependency') {
          return asset.addIncludedFile({
            filePath
          });
        }

        return Promise.resolve();
      }));
    }

    asset.setAST({
      type: 'posthtml',
      version: '0.4.1',
      program: JSON.parse(JSON.stringify(res.tree)) // posthtml adds functions to the AST that are not serializable

    });
    return [asset];
  },

  generate({
    ast
  }) {
    return {
      content: (0, _posthtmlRender.default)(ast.program)
    };
  }

});

exports.default = _default;