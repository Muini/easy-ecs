"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sourceMap = _interopRequireDefault(require("@parcel/source-map"));

var _plugin = require("@parcel/plugin");

var _utils = require("@parcel/utils");

var _postcss = _interopRequireDefault(require("postcss"));

var _postcssValueParser = _interopRequireDefault(require("postcss-value-parser"));

var _semver = _interopRequireDefault(require("semver"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const URL_RE = /url\s*\("?(?![a-z]+:)/;
const IMPORT_RE = /@import/;

function canHaveDependencies(filePath, code) {
  return !/\.css$/.test(filePath) || IMPORT_RE.test(code) || URL_RE.test(code);
}

var _default = new _plugin.Transformer({
  canReuseAST({
    ast
  }) {
    return ast.type === 'postcss' && _semver.default.satisfies(ast.version, '^7.0.0');
  },

  async parse({
    asset
  }) {
    // This is set by other transformers (e.g. Stylus) to indicate that it has already processed
    // all dependencies, and that the CSS transformer can skip this asset completely. This is
    // required because when stylus processes e.g. url() it replaces them with a dependency id
    // to be filled in later. When the CSS transformer runs, it would pick that up and try to
    // resolve a dependency for the id which obviously doesn't exist. Also, it's faster to do
    // it this way since the resulting CSS doesn't need to be re-parsed.
    if (asset.meta.hasDependencies === false) {
      return null;
    }

    let code = await asset.getCode();

    if (code != null && !canHaveDependencies(asset.filePath, code)) {
      return null;
    }

    return {
      type: 'postcss',
      version: '7.0.0',
      program: _postcss.default.parse(code, {
        from: asset.filePath
      })
    };
  },

  async transform({
    asset
  }) {
    // Normalize the asset's environment so that properties that only affect JS don't cause CSS to be duplicated.
    // For example, with ESModule and CommonJS targets, only a single shared CSS bundle should be produced.
    asset.setEnvironment({
      context: 'browser',
      engines: {
        browsers: asset.env.engines.browsers
      },
      minify: asset.env.minify
    }); // When this asset is an bundle entry, allow that bundle to be split to load shared assets separately.
    // Only set here if it is null to allow previous transformers to override this behavior.

    if (asset.isSplittable == null) {
      asset.isSplittable = true;
    } // Check for `hasDependencies` being false here as well, as it's possible
    // another transformer (such as PostCSSTransformer) has already parsed an
    // ast and CSSTransformer's parse was never called.


    let ast = await asset.getAST();

    if (!ast || asset.meta.hasDependencies === false) {
      return [asset];
    }

    let isDirty = false;
    ast.program.walkAtRules('import', rule => {
      let params = (0, _postcssValueParser.default)(rule.params);
      let [name, ...media] = params.nodes;
      let moduleSpecifier;

      if (name.type === 'function' && name.value === 'url' && name.nodes.length) {
        name = name.nodes[0];
      }

      moduleSpecifier = name.value;

      if (!moduleSpecifier) {
        throw new Error('Could not find import name for ' + rule);
      }

      if ((0, _utils.isURL)(moduleSpecifier)) {
        name.value = asset.addURLDependency(moduleSpecifier, {
          loc: (0, _utils.createDependencyLocation)(rule.source.start, asset.filePath, 0, 8)
        });
      } else {
        // If this came from an inline <style> tag, don't inline the imported file. Replace with the correct URL instead.
        // TODO: run CSSPackager on inline style tags.
        // let inlineHTML =
        //   this.options.rendition && this.options.rendition.inlineHTML;
        // if (inlineHTML) {
        //   name.value = asset.addURLDependency(dep, {loc: rule.source.start});
        //   rule.params = params.toString();
        // } else {
        media = _postcssValueParser.default.stringify(media).trim();
        let dep = {
          moduleSpecifier,
          // Offset by 8 as it does not include `@import `
          loc: (0, _utils.createDependencyLocation)(rule.source.start, moduleSpecifier, 0, 8),
          meta: {
            media
          }
        };
        asset.addDependency(dep);
        rule.remove(); // }
      }

      isDirty = true;
    });
    ast.program.walkDecls(decl => {
      if (URL_RE.test(decl.value)) {
        let parsed = (0, _postcssValueParser.default)(decl.value);
        let isDeclDirty = false;
        parsed.walk(node => {
          if (node.type === 'function' && node.value === 'url' && node.nodes.length > 0 && !node.nodes[0].value.startsWith('#') // IE's `behavior: url(#default#VML)`
          ) {
              let url = asset.addURLDependency(node.nodes[0].value, {
                loc: (0, _utils.createDependencyLocation)(decl.source.start, node.nodes[0].value)
              });
              isDeclDirty = node.nodes[0].value !== url;
              node.nodes[0].value = url;
            }
        });

        if (isDeclDirty) {
          decl.value = parsed.toString();
          isDirty = true;
        }
      }
    });

    if (isDirty) {
      asset.setAST(ast);
    }

    return [asset];
  },

  async generate({
    ast,
    options
  }) {
    let root = ast.program; // $FlowFixMe

    if (Object.getPrototypeOf(ast.program) === Object.prototype) {
      root = _postcss.default.root(ast.program);

      let convert = (parent, node, index) => {
        let type = node.type === 'atrule' ? 'atRule' : node.type;

        let result = _postcss.default[type](node);

        result.parent = parent;

        if (parent) {
          parent.nodes[index] = result;
        }

        if (result.walk) {
          // $FlowFixMe
          const container = result;
          container.each((node, index) => {
            convert(container, node, index);
          });
        }
      };

      root.each((node, index) => convert(root, node, index));
    }

    let result = await (0, _postcss.default)().process(root, {
      from: undefined,
      to: options.projectRoot + '/index',
      map: {
        annotation: false,
        inline: false
      },
      // Pass postcss's own stringifier to it to silence its warning
      // as we don't want to perform any transformations -- only generate
      stringifier: _postcss.default.stringify
    });
    let map;

    if (result.map != null) {
      map = new _sourceMap.default();
      map.addRawMappings(result.map.toJSON());
    }

    return {
      content: result.css,
      map
    };
  }

});

exports.default = _default;