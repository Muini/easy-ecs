"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _plugin = require("@parcel/plugin");

var _path = _interopRequireDefault(require("path"));

var _sourceMap = _interopRequireDefault(require("@parcel/source-map"));

var _tsUtils = require("@parcel/ts-utils");

var _TSModuleGraph = require("./TSModuleGraph");

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _collect = require("./collect");

var _shake = require("./shake");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = new _plugin.Transformer({
  async loadConfig({
    config,
    options
  }) {
    await (0, _tsUtils.loadTSConfig)(config, options);
  },

  async transform({
    asset,
    config,
    options,
    logger
  }) {
    let ts = await options.packageManager.require('typescript', asset.filePath, {
      autoinstall: options.autoinstall
    });
    let opts = {
      // React is the default. Users can override this by supplying their own tsconfig,
      // which many TypeScript users will already have for typechecking, etc.
      jsx: ts.JsxEmit.React,
      ...config,
      // Always emit output
      noEmit: false,
      noEmitOnError: false,
      declaration: true,
      declarationMap: true,
      isolatedModules: false,
      emitDeclarationOnly: true,
      outFile: 'index.d.ts',
      moduleResolution: ts.ModuleResolutionKind.NodeJs
    };
    let host = new _tsUtils.CompilerHost(options.inputFS, ts); // $FlowFixMe

    let program = ts.createProgram([asset.filePath], opts, host);
    let includedFiles = program.getSourceFiles().filter(file => _path.default.normalize(file.fileName) !== asset.filePath).map(file => ({
      filePath: file.fileName
    }));

    let mainModuleName = _path.default.relative(program.getCommonSourceDirectory(), asset.filePath).slice(0, -_path.default.extname(asset.filePath).length);

    let moduleGraph = new _TSModuleGraph.TSModuleGraph(ts, mainModuleName);
    let emitResult = program.emit(undefined, undefined, undefined, true, {
      afterDeclarations: [// 1. Build module graph
      context => sourceFile => {
        return (0, _collect.collect)(ts, moduleGraph, context, sourceFile);
      }, // 2. Tree shake and rename types
      context => sourceFile => {
        return (0, _shake.shake)(ts, moduleGraph, context, sourceFile);
      }]
    });
    let diagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);

    if (diagnostics.length > 0) {
      for (let diagnostic of diagnostics) {
        let filename = asset.filePath;
        let {
          file
        } = diagnostic;
        let diagnosticMessage = typeof diagnostic.messageText === 'string' ? diagnostic.messageText : diagnostic.messageText.messageText;
        let codeframe;

        if (file != null && diagnostic.start != null) {
          let source = file.text || diagnostic.source;

          if (file.fileName) {
            filename = file.fileName;
          } // $FlowFixMe


          if (source) {
            let lineChar = file.getLineAndCharacterOfPosition(diagnostic.start);
            let start = {
              line: lineChar.line + 1,
              column: lineChar.character + 1
            };
            let end = {
              line: start.line,
              column: start.column + 1
            };

            if (typeof diagnostic.length === 'number') {
              let endCharPosition = file.getLineAndCharacterOfPosition(diagnostic.start + diagnostic.length);
              end = {
                line: endCharPosition.line + 1,
                column: endCharPosition.character + 1
              };
            }

            codeframe = {
              code: source,
              codeHighlights: {
                start,
                end,
                message: diagnosticMessage
              }
            };
          }
        }

        logger.warn({
          message: diagnosticMessage,
          filePath: filename,
          codeFrame: codeframe ? codeframe : undefined
        });
      }
    }

    let code = (0, _nullthrows.default)(host.outputCode);
    code = code.substring(0, code.lastIndexOf('//# sourceMappingURL'));
    let map = JSON.parse((0, _nullthrows.default)(host.outputMap));
    map.sources = map.sources.map(source => _path.default.join(_path.default.dirname(asset.filePath), source));
    let sourceMap = null;

    if (map.mappings) {
      sourceMap = new _sourceMap.default();
      sourceMap.addRawMappings(map);
    }

    return [{
      type: 'ts',
      content: code,
      map: sourceMap,
      includedFiles
    }];
  }

});

exports.default = _default;