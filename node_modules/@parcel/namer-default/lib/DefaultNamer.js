"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _plugin = require("@parcel/plugin");

var _diagnostic = _interopRequireDefault(require("@parcel/diagnostic"));

var _assert = _interopRequireDefault(require("assert"));

var _path = _interopRequireDefault(require("path"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const COMMON_NAMES = new Set(['index', 'src', 'lib']);

var _default = new _plugin.Namer({
  name({
    bundle,
    bundleGraph,
    options
  }) {
    // If the bundle has an explicit file path given (e.g. by a target), use that.
    if (bundle.filePath != null) {
      // TODO: what about multiple assets in the same dep?
      // e.g. input is a Vue file, output is JS + CSS
      // which is defined as a target in package.json?
      return bundle.filePath;
    }

    let bundleGroup = bundleGraph.getBundleGroupsContainingBundle(bundle)[0];
    let bundleGroupBundles = bundleGraph.getBundlesInBundleGroup(bundleGroup);

    if (bundle.isEntry) {
      let entryBundlesOfType = bundleGroupBundles.filter(b => b.isEntry && b.type === bundle.type);
      (0, _assert.default)(entryBundlesOfType.length === 1, // Otherwise, we'd end up naming two bundles the same thing.
      'Bundle group cannot have more than one entry bundle of the same type');
    }

    let mainBundle = (0, _nullthrows.default)(bundleGroupBundles.find(b => {
      var _b$getMainEntry;

      return ((_b$getMainEntry = b.getMainEntry()) === null || _b$getMainEntry === void 0 ? void 0 : _b$getMainEntry.id) === bundleGroup.entryAssetId;
    }));

    if (bundle.id === mainBundle.id && bundle.isEntry && bundle.target && bundle.target.distEntry != null) {
      let loc = bundle.target.loc;
      let distEntry = bundle.target.distEntry;

      if (_path.default.extname(bundle.target.distEntry).slice(1) !== bundle.type && loc) {
        let fullName = _path.default.relative(_path.default.dirname(loc.filePath), _path.default.join(bundle.target.distDir, distEntry));

        let err = new _diagnostic.default({
          diagnostic: {
            message: `Target "${bundle.target.name}" declares an output file path of "${fullName}" which does not match the compiled bundle type "${bundle.type}".`,
            filePath: loc.filePath,
            codeFrame: {
              codeHighlights: {
                start: loc.start,
                end: loc.end,
                message: `Did you mean "${fullName.slice(0, -_path.default.extname(fullName).length) + '.' + bundle.type}"?`
              }
            },
            hints: [`Try changing the file extension of "${bundle.target.name}" in ${_path.default.relative(process.cwd(), loc.filePath)}.`]
          }
        });
        throw err;
      }

      return bundle.target.distEntry;
    } // Base split bundle names on the first bundle in their group.
    // e.g. if `index.js` imports `foo.css`, the css bundle should be called
    //      `index.css`.


    let name = nameFromContent(mainBundle, options.rootDir);

    if (!bundle.isEntry) {
      name += '.' + bundle.hashReference;
    }

    return name + '.' + bundle.type;
  }

});

exports.default = _default;

function nameFromContent(bundle, rootDir) {
  let entryFilePath = (0, _nullthrows.default)(bundle.getMainEntry()).filePath;
  let name = basenameWithoutExtension(entryFilePath); // If this is an entry bundle, use the original relative path.

  if (bundle.isEntry) {
    // Match name of target entry if possible, but with a different extension.
    if (bundle.target.distEntry != null) {
      return basenameWithoutExtension(bundle.target.distEntry);
    }

    return _path.default.join(_path.default.relative(rootDir, _path.default.dirname(entryFilePath)), name).replace(/\.\.(\/|\\)/g, '__$1');
  } else {
    // If this is an index file or common directory name, use the parent
    // directory name instead, which is probably more descriptive.
    while (COMMON_NAMES.has(name)) {
      entryFilePath = _path.default.dirname(entryFilePath);
      name = _path.default.basename(entryFilePath);
    }

    return name;
  }
}

function basenameWithoutExtension(file) {
  return _path.default.basename(file, _path.default.extname(file));
}